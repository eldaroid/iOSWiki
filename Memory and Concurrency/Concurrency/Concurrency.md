 # Многопоточность
 
1. [Dispatch Queues](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW28)
2. [Углубленный анализ оптимизации производительности Swift](https://russianblogs.com/article/764556451/)
3. [iOS Concurrency — Underlying Truth](https://chetan-aggarwal.medium.com/ios-concurrency-underlying-truth-1021a0bb2a98)
4. [Concurrent Programming](https://www.oreilly.com/library/view/high-performance-ios/9781491910993/ch04.html)

## Многопоточность

В мире операционных систем существуют две сущности, где запускаются наши программы (некие изолированные капсулы) - **процессы**,**потоки (thread)**. Каждое приложение состоит как минимум из 1 процесс. А процесс состоит хотя бы из 1 потока (main). 

![](https://www.w3.org/People/Frystyk/thesis/MultiStackThread.gif)

Все потоки разделяют общие ресурсы потока (память, файловые дескрипторы, процессорное время). У каждого потока есть свой стэк (областья память, куда сохраняются локальные переменные функции, пока эта функция сохраняется). 

Управление потоками необходимо чтобы: 1) сделать приложение быстрым, предотвратить зависающий UI, реагировать на действия пользователей без задержки; 2) параллельно обрабатывать данные; 

> Мы не можем использовать больше потоков, чем ядер у нашего процессора. 

При написании многопоточных приложений требуется работать с общими данными из разных потоков. 

## История

Потоки POSIX

В конце 1980-х и начале 1990-х было несколько разных API, но в 1995 г. POSIX.1c стандартизовал потоки POSIX, позже это стало частью спецификаций SUSv3. В наше время многоядерные процессоры проникли даже в настольные ПК и смартфоны, так что даже у большинства машин есть низкоуровневая аппаратная поддержка, позволяющая им одновременно выполнять несколько потоков. В былые времена одновременное исполнение потоков на одноядерных ЦПУ было лишь впечатляюще изобретательной, но очень эффективной иллюзией.

> Posix Threads или Pthreads определяет набор типов и функций на Си.

Pthreads - самый низкий уровень управления потоками, доступные в приложении. Он дает почти прямой доступ к управлению потоками ядра OS. В swift эта бибилиотека обычно не используется из-за сложности и необходимости рабоыт с указателями. 

iOS SDK дает более простой способ управления потоками - `class Thread`. 

```swift
let thread = Thread {
  // вычисления
}
thread.start()
```

## 

## Способы достижения многопоточности в iOS и macOS

Существует три способа достижения параллелизма в iOS:

* Потоки (threads);
* [GCD](./GCD.md);
* NSOperationQueue;

> Последующие методы работы многопоточности в iOS - это всего лишь удобные обертки над unix потоками: судя по стеку вызовов NSThread использует pthread. Насчет dispatch он использует darwin-libpthread

Недостатком потоков является то, что они немасштабируемы для разработчика. Вы должны решить, сколько потоков нужно создать и изменять их число динамически в соответствии с условиями. Кроме того, приложение принимает на себя большую часть затрат, связанных с созданием и встраиванием потоков, которые оно использует.

Поэтому в macOS и iOS предпочтительно использовать асинхронный подход к решению проблемы параллелизма, а не полагаться на потоки.

Одной из технологий асинхронного запуска задач является Grand Central Dispatch (GCD), которая отводит управление потоками до уровня системы. Все, что разработчик должен сделать, это определить выполняемые задачи и добавить их в соответствующую очередь отправки. GCD заботится о создании необходимых потоков и время для работы в этих потоках.

Все `dispatch queues` представляют собой структуры данных FIFO, поэтому задачи всегда запускаются в том же порядке, в котором они добавлены.

В отличие от dispatch queue очереди операций (NSOperation Queue) не ограничиваются выполнением задач в порядке FIFO и поддерживают создание сложных графиков выполнения заказов для ваших задач.

## Разница между синхронными и асинхронными задачами, однопоточностью и многопоточностью

Ниже описаны термины в привязке к GCD, но с небольшими изменениями они верны и для программирования в целом.

Синхронная операция начинает выполнятся сразу при вызове, блокирует поток. Выполняется в текущем потоке. Асинхронная операция ставит задачу в очередь выполнения, продолжает выполнение кода, из которого вызвана задача. Если очередь однопоточная, то задача будет выполнятся после выполнения всех задач, которые уже поставлены в очередь, если много поточная - возможно ее выполнение в другом потоке.

Нужно запомнить, что синхронность-асинхронность и однопоточность-многопоточность две пары разных характеристить, и одни не зависят от других (и синхронность и асинхронность могут работать как в однопоточной среде, так и в многопоточной)


## Что такое мьютекс (mutex)?

При написании многопоточных приложений требуется работать с общими данными из разных потоков и синхронизировать их. Для синхронизации потоков существуют объекты синхронизации - мьютекс (в iOS SDK они реализуются в виде [NSLock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/Concurrency.md#:~:text=Мьютекс%20-%20NSlock) и NSRecursiveLock).

Мьютекс является одним из видов семафора, который предоставляет доступ одновременно только одному потоку. Если мьютекс используется и другой поток пытается получить его, что поток блокируется до тех пор, пока мьютекс не освободится от своего первоначального владельца. Если несколько потоков соперничают за одни и те же мьютексы, только одному будет разрешен к нему доступ.

## Что такое семафор (semafor)?

Семафор позволяет выполнять какой-либо участок кода одновременно только конкретному количеству потоков. В основе семафора лежит счетчик, который и определяет, можно ли выполнять участок кода текущему потоку или нет. Если счетчик больше нуля — поток выполняет код, в противном случае — нет. В GCD выглядит так: semaphore_create – создание семафора (аналог sem_init)
semaphore_destroy – удаление, соответственно (аналог sem_destroy)
semaphore_wait – блокирующее ожидание на семафоре (аналог sem_wait)
semaphore_signal – освобождение семафора (аналог sem_post)

## Пример мьютекса - NSlock

Пример, где можно использовать мьютекс NSLock:

```swift
var counter = 0 
let thread1 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Операция увеличения счетчика не [атомарно](https://github.com/eldaroid/iOSWiki/blob/master/Swift/Glossary.md#:~:text=Атомарность). Оно состоит из нескольких ша: 

```swift
let tmp = counter + 1
counter = tmp
```

Может произойти ситуация, когда оба потока могут оказаться в точке кода, производящей запись или чтение. Для исправления ситуации нужно синхронизовать обращение к счетчику. 


```swift
var counter = 0
let lock = NSLock()
let thread1 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Участок кода между `lock()` и `unlock()` называется критическая секция. NSLock позволяет вызывать `unlock()` только тому потоку с которого был вызван `lock()`.

[Deadlock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/ProblemsOfConcurrency.md#:~:text=deadlock):

```swift
let lock = NSLock()
lock.lock()
lock.lock() // deadlock()
```

Исправление deadlock:

```swift
let lock = NSRecursiveLock()
lock.lock()
lock.lock()
lock.unlock()
lock.unlock()
```

## Threads in Xcode

Во время отладки существуют [встроенные команды](https://codeswift.ru/wp-content/uploads/2022/02/12.png) упрощающие понимание деталей текущего потока. 

```swift
// команды для печати
po Thread.isMainThread
po Thread.isMultiThreaded()
po Thread.current
po Thread.main
```
