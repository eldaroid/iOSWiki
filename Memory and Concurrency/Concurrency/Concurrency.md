 # Многопоточность
 
1. [Dispatch Queues](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW28)
2. [Углубленный анализ оптимизации производительности Swift](https://russianblogs.com/article/764556451/)
 
## Диспетчеризация

Поток можно считать меньшей единицей выполнения приложения. Каждому приложению принадлежит минимум один поток, который называется основным (main thread). Этот поток запускается операционной системой, когда вызывается метод main() приложения; это происходит при старте приложения. Заметьте, что более-менее одно и то же происходит на всех поддерживаемых платформах — как работающих на мощных компьютерах, так и на устройствах под управлением Windows Phone с ограниченными вычислительными ресурсами.

> Объект, отвечающий за управление очередью, называется **диспетчером потока** (thread’s dispatcher)

При вызове какого-либо метода операция добавляется в очередь. Каждая операция выполняется последовательно, в соответствии с порядком, в котором она была добавлена в очередь (хотя на порядок выполнения операций можно повлиять, назначив им приоритеты).

При необходимости приложение может запускать новые потоки — как явным образом в коде, так и неявным, с помощью некоторых библиотек или ОС. В основном цель запуска нового потока — выполнение какой-либо операции (или ожидание результата этой операции) без блокирования остальной части приложения.

> Диспетчеризацией методов называют процесс поиска адреса инструкций, которые нужно выполнить CPU при вызове определенного метода (какую системе имплементацию метода вызвать)

Другими словами, цель диспетчеризации методов состоит в том, чтобы программа сообщала процессору, где он может найти исполняемый код конкретного метода в памяти.

Диспетчеризация происходит каждый раз, когда вызывается метод:

<img src="https://habrastorage.org/getpro/habr/upload_files/a12/221/b3c/a12221b3cd7f8d47cd3345d6d313bdfb.png" alt="alt text" width="350" height="250">

## Виды диспетчеризации

* Статическая диспетчеризация (Static dispatch) - все value type (структуры, массивы).

Статическая диспетчеризация — это **самый быстрый стиль диспетчеризации методов**. Это не только приводит к наименьшему количеству ассемблерных инструкций, но и компилятор может выполнять всевозможные умные трюки, такие как встраивание кода. Уже во время сборки компилятор знает, что вызывать и когда. Static Dispatch ускоряет работу вашего приложения, но вы не можете использовать его с подклассами. Этот тип используется в языке C и является самым быстрым.

> Примечание. Методы расширения всегда используют статическую диспетчеризацию.

* Динамическая диспетчиризация (Dynamic dispatch)

Во время выполнения программы на основании типа объекта система решает, какую именно реализацию метода вызывать. В одной стороны, это нам дает ряд преимуществ - мы можем работать с объектом производного типа как с объектом базового типа и использовать его везде, где требуется объект базового типа. Но с другой стороны, поскольку решение о выбере реализации принимается во время выполнения, то это несколько замедляет общий ход работы программы.

Для повышения производительности, задача компилятора и разработчика заключается в том, чтобы, как можно больше методов использовали статическую диспетчеризацию, в этом нам поможет следующие ключевые слова:

  I. final  не позволяет наследоваться классам (override), а методам переопределяться, что приводит к статической диспетчеризации

  II. private ограничивает видимость метода или всего класса. Отсутствие каких-либо переопределений позволяет компилятору автоматически добавлять ключевое слово final

  III. Whole Module Optimization позволяет компилятору просматривать все исходные файлы в едином модуле. Это позволяет компилятору использовать final для всех методов без переопределений.

[Данная статья Apple](https://developer.apple.com/swift/blog/?id=27) более подробно рассказывает про способы повышения производительности, уменьшая использование табличной диспетчеризации.

## Типы диспетчеризации

Перейдем к типам диспетчеризации на языке Swift. Существует три вида: 

* Direct Dispatch (статическая);

Пример:
```swift
final class MyClass() {
    func someMethod() {
        print("Direct Dispatch")
    }
}
```

* Table Dispatch (динамическая, в свою очередь, делится на Virtual Table и Witness Table);
* Message Dispatch (самая динамическая диспетчеризация);

<img src="https://hsto.org/getpro/habr/upload_files/17e/f12/078/17ef120789f74352f33c617df5996a4b.png" alt="alt text" width="600" height="250">


## История

Потоки POSIX

В конце 1980-х и начале 1990-х было несколько разных API, но в 1995 г. POSIX.1c стандартизовал потоки POSIX, позже это стало частью спецификаций SUSv3. В наше время многоядерные процессоры проникли даже в настольные ПК и смартфоны, так что даже у большинства машин есть низкоуровневая аппаратная поддержка, позволяющая им одновременно выполнять несколько потоков. В былые времена одновременное исполнение потоков на одноядерных ЦПУ было лишь впечатляюще изобретательной, но очень эффективной иллюзией.

> Posix Threads или Pthreads определяет набор типов и функций на Си.

Pthreads - самый низкий уровень управления потоками, доступные в приложении. Он дает почти прямой доступ к управлению потоками ядра OS. В swift эта бибилиотека обычно не используется из-за сложности и необходимости рабоыт с указателями. 

iOS SDK дает более простой способ управления потоками - `class Thread`. 

```swift
let thread = Thread {
  // вычисления
}
thread.start()
```

При написании многопоточных приложений требуется работать с общими данными из разных потоков и синхронизировать их. Для синхронизации потоков существуют объекты синхронизации - мьютекс (в iOS SDK они реализуются в виде [NSLock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/Concurrency.md#:~:text=Мьютекс%20-%20NSlock) и NSRecursiveLock).

## Многопоточность

Каждое приложение состоит как минимум из 1 процесс. А процесс состоит хотя бы из 1 потока (main), о котором мы писали ранее. Все потоки разделяют общие ресурсы потока (память, файловые дескрипторы, процессорное время). У каждого потока есть свой стэк (областья память, куда сохраняются локальные переменные функции, пока эта функция сохраняется). 

Управление потоками необходимо чтобы: 1) сделать приложение быстрым, предотвратить зависающий UI, реагировать на действия пользователей без задержки; 2) параллельно обрабатывать данные; 

> Мы не можем использовать больше потоков, чем ядер у нашего процессора. 

При написании многопоточных приложений требуется работать с общими данными из разных потоков. 

## Мьютекс - NSlock

Пример, где можно использовать мьютекс NSLock:

```swift
var counter = 0 
let thread1 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Операция увеличения счетчика не [атомарно](https://github.com/eldaroid/iOSWiki/blob/master/Swift/Glossary.md#:~:text=Атомарность). Оно состоит из нескольких ша: 

```swift
let tmp = counter + 1
counter = tmp
```

Может произойти ситуация, когда оба потока могут оказаться в точке кода, производящей запись или чтение. Для исправления ситуации нужно синхронизовать обращение к счетчику. 


```swift
var counter = 0
let lock = NSLock()
let thread1 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Участок кода между `lock()` и `unlock()` называется критическая секция. NSLock позволяет вызывать `unlock()` только тому потоку с которого был вызван `lock()`.

[Deadlock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/ProblemsOfConcurrency.md#:~:text=deadlock):

```swift
let lock = NSLock()
lock.lock()
lock.lock() // deadlock()
```

Исправление deadlock:

```swift
let lock = NSRecursiveLock()
lock.lock()
lock.lock()
lock.unlock()
lock.unlock()
```

## Threads in Xcode

Во время отладки существуют [встроенные команды](https://codeswift.ru/wp-content/uploads/2022/02/12.png) упрощающие понимание деталей текущего потока. 

```swift
// команды для печати
po Thread.isMainThread
po Thread.isMultiThreaded()
po Thread.current
po Thread.main
```
