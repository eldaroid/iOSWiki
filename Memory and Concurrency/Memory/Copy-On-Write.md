# Copy On Write (CoW)

1. :heavy_check_mark: [Understanding Swift Copy-on-Write mechanisms](https://medium.com/@lucianoalmeida1/understanding-swift-copy-on-write-mechanisms-52ac31d68f2f)

### Зачем CoW нужна

|Value Types (хранятся в [стеке](./RandomAccessMemory/Stack.md)) | Referene Types (хранятся в [куче](./RandomAccessMemory/Heap.md))|
|------------|------------|
|Struct | Class|
|Enum | Function|
|Double | Closure|
|String | |
|Set | |
|Tuple | |
|Array | |
|Dictionary | |

Основным отличием [ссылочных типов](/) от типов значений является то, что первые передаются по ссылкам, в то время как вторые копируются. У этого есть ряд своих плюсов таких как то, что типы значений работают быстрее, потому что хранятся на стеке, а не в куче, используют статическую диспетчеризацию и прочее. Однако можно задаться вопросом “а зачем копировать данные, если мы их не меняем?”. Пример, представьте себе массив с 1000 элементами внутри него: если вы скопируете этот массив в другую переменную, Swift должен будет скопировать все 1000 элементов, даже если два массива окажутся одинаковыми.





Эта проблема решается с помощью копирования при записи: когда вы указываете две переменные на один и тот же массив, они обе указывают на одни и те же базовые данные.

если вы измените вторую переменную, Swift сделает полную копию в этой точке, так что будет изменена только вторая переменная, а первая не изменится.

Таким образом, откладывая операцию копирования до тех пор, пока она действительно не понадобится, Swift может гарантировать, что работа не будет выполнена впустую.


