 
## Диспетчеризация

1. [iOS-Инкубатор. Диспетчеризация в iOS](https://hackmd.io/@leonovka/B1IaedbHs)
2. [Диспетчеризация методов в Swift](https://habr.com/ru/articles/714830/)
3. [Диспетчеризация методов iOS](https://habr.com/ru/articles/677616/)

> Диспетчеризацией методов называют процесс поиска адреса инструкций, которые нужно выполнить CPU при вызове определенного метода (какую имплементацию система вызовет у метода).

Другими словами, цель диспетчеризации методов состоит в том, чтобы **программа сообщала процессору, где он может найти исполняемый код конкретного метода в памяти**.

Диспетчеризация происходит каждый раз, когда вызывается метод:

<img src="https://habrastorage.org/getpro/habr/upload_files/a12/221/b3c/a12221b3cd7f8d47cd3345d6d313bdfb.png" alt="alt text" width="350" height="250">

## Виды диспетчеризации

Основные виды диспетчеризации:
* **Java**: табличная (по дефолту) / статическая через final
* **C++**: статическая (по дефолту) / табличная через virtual
* **Objective-C**: на сообщениях
  * Из-за поддержки ЯП `C` можно исп-ть и static
* **Swift**: есть все виды

<img src="https://hsto.org/getpro/habr/upload_files/17e/f12/078/17ef120789f74352f33c617df5996a4b.png" alt="alt text" width="600" height="250">

### 1) Статическая диспетчеризация (Static dispatch) - все value type (структуры, массивы).

Статическая диспетчеризация — это **самый быстрый стиль диспетчеризации методов**. Это не только приводит к наименьшему количеству ассемблерных инструкций, но и компилятор может выполнять всевозможные умные трюки, такие как [встраивание кода(атрибут @inline)](/Swift/Swift.md). 

* На этапе компиляции полностью разруливаются вызовы методов;
* Запрещает наследование (не можете использовать его с подклассами) и переопределение методов
* Static dispatch используется в языке C и является самым быстрым

> Примечание. [Методы расширения всегда используют статическую диспетчеризацию](/5%20Swift/5.4%20Protocol/Protocol.md)

Static dispatch - это обход принципа [полиморфизма в ООП](/2%20ComputerScience/2.2%20Languages/2.2.2%20Paradigm/2.2.2.2%20Imperative/2.2.2.2.2%20OOP.md).

### 2) Table Dispatch (динамическая, делится на Virtual Table и Witness Table

* Позволяет реализовать принцип [полиморфизма из ООП](/2%20ComputerScience/2.2%20Languages/2.2.2%20Paradigm/2.2.2.2%20Imperative/2.2.2.2.2%20OOP.md);
* Во время выполнения программы (**в runtime**) на основании типа объекта система вызывает метод;
* Появляются таблицы ссылок на методы;
* Каждый наследник имеет свою измененную копию таблицы;

Дает ряд преимуществ - можно работать с объектом производного типа как с объектом базового типа и использовать его везде, где требуется объект базового типа.

  1. **[Virtual table (для классов)](/5%20Swift/5.3%20DataRepresentations/5.3.1%20DataTypes/5.3.1.3%20ReferenceTypes/Class/)** - таблица, прикрепленная к классу, реализацию которой следует использовать для каждого переопределяемого метода в классе. В отличие от таблицы методов Objective-C, ключи виртуальной таблицы представляют собой просто смещения, что значительно упрощает поиск за счет динамизма и дублирования информации о непереопределенных методах.

  2. **[Witness table (для протоколов)](/5%20Swift/5.4%20Protocol/Protocol.md)** - в [SIL](/Swift/Swift.md) (и во время runtime) представление соответствия протоколу

      Cлово **Witness** - значение или тип, удовлетворяющий требованию протокола. Отсюда и название Witness Table.

### 3) Message Dispatch (самая динамическая диспетчеризация)

> Работает с указателями на методы Objective-C в runtime

* Во время выполнения программы (**в runtime**) на основании указателя на метод система вызывает его;
* Позволяет реализовать [полиморфизма из ООП](/2%20ComputerScience/2.2%20Languages/2.2.2%20Paradigm/2.2.2.2%20Imperative/2.2.2.2.2%20OOP.md);
* Еще более динамическое поведение, чем у табличной;
* Позволяет swizzling/isa-swizzling;

В Obj-C используется message Dispatch. У каждого объекта есть ссылка issa (объект класса, не экзампляр), где хранится словарь с ключами в виде selector`а и значениями в виде ссылки на функции. Когда вызывается метод туда передается селектор и сам объект (который этот метод вызывает), которому придет это сообщение.

![messageDispatch](https://github.com/eldaroid/pictures/blob/master/iOSWiki/Swift/messageDispatch.png?raw=true)

## Оптимизация диспетчеризации вызовов

[Данная статья Apple](https://developer.apple.com/swift/blog/?id=27) более подробно рассказывает про способы повышения производительности, уменьшая использование табличной диспетчеризации.

Для повышения производительности, задача компилятора и разработчика заключается в том, чтобы, как можно больше методов использовали статическую диспетчеризацию, в этом нам поможет следующие ключевые слова:

  I. final  не позволяет наследоваться классам (override), а методам переопределяться, что приводит к статической диспетчеризации

    Пример:
    ```swift
    final class MyClass() {
        func someMethod() {
            print("Direct Dispatch")
        }
    }
    ```

  II. `private` ограничивает видимость метода или всего класса. Отсутствие каких-либо переопределений позволяет компилятору автоматически добавлять ключевое слово final

  III. [Whole Module Optimization](https://github.com/apple/swift/blob/main/docs/Lexicon.md#wmo-whole-module-optimization) позволяет компилятору просматривать все исходные файлы в едином модуле (все файлы в модуле компилируются в одном процессе), проверяются и оптимизируются вместе на уровне [SIL](https://github.com/apple/swift/blob/main/docs/SIL.rst). Это позволяет компилятору использовать final для всех методов без переопределений.

## Общие правила диспетчеризации на рисунке:

![alt text](https://habrastorage.org/getpro/habr/upload_files/21e/9c1/138/21e9c1138c6b0eb862d264ce5fb1b221.png)
