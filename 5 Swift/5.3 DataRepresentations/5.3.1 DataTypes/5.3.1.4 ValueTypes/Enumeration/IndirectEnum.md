## Indirect Enum

Enumeration (Enum) определяет общий тип для группы [связанных значений (associate value)](./Enumeration.md) и позволяет вам работать с этими значениями типобезопасным способом в вашем коде. Иногда нам также нужно иметь ассоциированные значения (`name: String`):

```swift
enum Family {
    case mother(name: String)
    case father(name: String)
    case child(name: String, Int)
}
```

#### Что произойдет, если мы попытаемся указать в ассоциированном значении само рекурсивное наше перечисление?

```swift
enum FamilyNode {
    case parent(FamilyNode?)
    case child(FamilyNode?)
}
```

❗❗❗ Ошибка компилятора: `Recursive enum ‘%EnumName’ is not marked ‘indirect’`

> [Перечисления](./Enumeration.md) — это [типы значений](/5%20Swift/5.3%20DataRepresentations/5.2.1%20DataTypes/5.2.1.4%20ValueTypes/), которые по специфики управления [памятью Apple](/3%20Memory%20and%20Concurrency/3.1%20Memory/3.1.1%20AboutMemory/3.1.1.1%20Memory.md) должны быть определены **во время компиляции**. То есть необходимо точно знать, сколько ячеек памяти нам нужно выделить для каждого экземпляра, хранящегося в [стеке](/3%20Memory%20and%20Concurrency/3.1%20Memory/3.1.2%20RandomAccessMemory/3.1.2.2%20Stack.md). 

Определяя внутри одного объекта типа значения тот же объект типа значения, мы создаем [рекурсию](https://github.com/eldaroid/iOSWiki/blob/master/2%20ComputerScience/2.2%20Languages/2.2.2%20Paradigm/2.2.2.1%20Declarative/2.2.2.1.1%20FunctionalProgramming(FP).md#рекурсия), в которой невозможно понять, сколько памяти нужно для выделить такого объекта. Фактически, выводится еще одна проблема: мы не можем определить свойство типа A внутри структуры A.

```swift
struct Woman {
    var name: String
    var friend: Woman?
}
```

❗❗❗ Ошибка компилятора: `Value type 'Woman' cannot have a stored property that recursively contains it`

Вернемся к нашей проблеме и попробуем выяснить, как Swift работает с перечислениями [связанных значений](./Enumeration.md) и почему возникает проблема:

* Enum Swift объект будет иметь только один случай, назначенный самому себе (невозможно назначить два значения одновременно);
* Затем компилятор проверяет, какой случай перечисления займет максимальный объем памяти;
* Теперь экземпляр enum будет иметь необходимую память плюс некоторую статическую память для отслеживания текущей выбранной позиции из enum (называется это активный случай);

Ответ: Если бы value типы были бы рекурсивными, это привело бы к бесконечной вложенности и, как следствие, к ошибкам в вычислении размера памяти.

> С reference типами нет такой проблемы, тк они вычислиются на этапе runtime

#### Решение рекурсии - Indirect

`Indirect` модифицирует способ хранения перечислений в Swift, чтобы они могли расти до любого размера

```swift
indirect enum FamilyNode {
    case parent(FamilyNode?)
    case child(FamilyNode?)
}
```

или

```swift
enum FamilyNode {
    indirect case parent(FamilyNode?)
    indirect case child(FamilyNode?)
    case pets
}
```

Что происходит, когда мы указываем indirect модификатор объявления?
Объяснение достаточно простое: Indirect указывает компилятору хранить данные enum за указателем. То есть, для хранения ссылки в стеке выделяется статический размер памяти, но содержимое (как я предполагаю) хранится в куче. Таким образом, после этих оптимизаций нет необходимости делать экземпляр Enum достаточно большим, чтобы вместить все данные.

---