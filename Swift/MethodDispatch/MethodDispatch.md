 
## Диспетчеризация

1. [iOS-Инкубатор. Диспетчеризация в iOS](https://hackmd.io/@leonovka/B1IaedbHs)
2. [Диспетчеризация методов в Swift](https://habr.com/ru/articles/714830/)
3. [Диспетчеризация методов iOS](https://habr.com/ru/articles/677616/)

> Диспетчеризацией методов называют процесс поиска адреса инструкций, которые нужно выполнить CPU при вызове определенного метода (какую системе имплементацию метода вызвать).

Другими словами, цель диспетчеризации методов состоит в том, чтобы **программа сообщала процессору, где он может найти исполняемый код конкретного метода в памяти**.

Диспетчеризация происходит каждый раз, когда вызывается метод:

<img src="https://habrastorage.org/getpro/habr/upload_files/a12/221/b3c/a12221b3cd7f8d47cd3345d6d313bdfb.png" alt="alt text" width="350" height="250">

## Виды диспетчеризации

<img src="https://hsto.org/getpro/habr/upload_files/17e/f12/078/17ef120789f74352f33c617df5996a4b.png" alt="alt text" width="600" height="250">

### Статическая диспетчеризация (Static dispatch) - все value type (структуры, массивы).

Статическая диспетчеризация — это **самый быстрый стиль диспетчеризации методов**. Это не только приводит к наименьшему количеству ассемблерных инструкций, но и компилятор может выполнять всевозможные умные трюки, такие как встраивание кода. Уже во время сборки компилятор знает, что вызывать и когда. Static Dispatch ускоряет работу вашего приложения, но вы не можете использовать его с подклассами. Этот тип используется в языке C и является самым быстрым.

> Примечание. Методы расширения всегда используют статическую диспетчеризацию.

### Table Dispatch (динамическая, в свою очередь, делится на [Virtual Table](https://github.com/apple/swift/blob/main/docs/Lexicon.md#vtable-virtual-dispatch-table) и [Witness Table](https://github.com/apple/swift/blob/main/docs/Lexicon.md#witness))

Во время выполнения программы на основании типа объекта система решает, какую именно реализацию метода вызывать. В одной стороны, это нам дает ряд преимуществ - мы можем работать с объектом производного типа как с объектом базового типа и использовать его везде, где требуется объект базового типа. Но с другой стороны, поскольку решение о выборе реализации принимается во время выполнения, то это несколько замедляет общий ход работы программы.

  1. [Virtual tabl](https://github.com/apple/swift/blob/main/docs/Lexicon.md#vtable-virtual-dispatch-table). Карта, прикрепленная к классу, реализацию которой следует использовать для каждого переопределяемого метода в классе. В отличие от таблицы методов Objective-C, ключи виртуальной таблицы представляют собой просто смещения, что значительно упрощает поиск за счет динамизма и дублирования информации о непереопределенных методах.

  2. [Witness](https://github.com/apple/swift/blob/main/docs/Lexicon.md#witness-table) - в SIL (и во время runtime) представление соответствия протоколу; по сути [virtual table](https://github.com/apple/swift/blob/main/docs/Lexicon.md#vtable-virtual-dispatch-table), но для протокола вместо класса.

### Message Dispatch (самая динамическая диспетчеризация);


## Оптимизация диспетчеризации вызовов

[Данная статья Apple](https://developer.apple.com/swift/blog/?id=27) более подробно рассказывает про способы повышения производительности, уменьшая использование табличной диспетчеризации.

Для повышения производительности, задача компилятора и разработчика заключается в том, чтобы, как можно больше методов использовали статическую диспетчеризацию, в этом нам поможет следующие ключевые слова:

  I. final  не позволяет наследоваться классам (override), а методам переопределяться, что приводит к статической диспетчеризации

    Пример:
    ```swift
    final class MyClass() {
        func someMethod() {
            print("Direct Dispatch")
        }
    }
    ```

  II. `private` ограничивает видимость метода или всего класса. Отсутствие каких-либо переопределений позволяет компилятору автоматически добавлять ключевое слово final

  III. [Whole Module Optimization](https://github.com/apple/swift/blob/main/docs/Lexicon.md#wmo-whole-module-optimization) позволяет компилятору просматривать все исходные файлы в едином модуле (все файлы в модуле компилируются в одном процессе), проверяются и оптимизируются вместе на уровне [SIL](https://github.com/apple/swift/blob/main/docs/SIL.rst). Это позволяет компилятору использовать final для всех методов без переопределений.

> [Swift Intermediate Language (SIL)](https://github.com/apple/swift/blob/main/docs/SIL.rst) - это промежуточный язык высокого уровня, используемый компилятором Swift, заполняющий пробел между AST и LLVM IR, подходящий для дальнейшего анализа и оптимизации кода Swift.

## Общие правила диспетчеризации на рисунке:

![alt text](https://habrastorage.org/getpro/habr/upload_files/21e/9c1/138/21e9c1138c6b0eb862d264ce5fb1b221.png)
