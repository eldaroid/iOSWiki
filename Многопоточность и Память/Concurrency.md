 # Многопоточность
 
1. [Dispatch Queues](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW28)
2. [Углубленный анализ оптимизации производительности Swift](https://russianblogs.com/article/764556451/)
 
## Диспетчеризация

Поток можно считать меньшей единицей выполнения приложения. Каждому приложению принадлежит минимум один поток, который называется основным (main thread). Этот поток запускается операционной системой, когда вызывается метод main() приложения; это происходит при старте приложения. Заметьте, что более-менее одно и то же происходит на всех поддерживаемых платформах — как работающих на мощных компьютерах, так и на устройствах под управлением Windows Phone с ограниченными вычислительными ресурсами.

> Объект, отвечающий за управление очередью, называется **диспетчером потока** (thread’s dispatcher)

При вызове какого-либо метода операция добавляется в очередь. Каждая операция выполняется последовательно, в соответствии с порядком, в котором она была добавлена в очередь (хотя на порядок выполнения операций можно повлиять, назначив им приоритеты).

При необходимости приложение может запускать новые потоки — как явным образом в коде, так и неявным, с помощью некоторых библиотек или ОС. В основном цель запуска нового потока — выполнение какой-либо операции (или ожидание результата этой операции) без блокирования остальной части приложения.

> Диспетчеризацией методов называют процесс поиска адреса инструкций, которые нужно выполнить CPU при вызове определенного метода (какую системе имплементацию метода вызвать)

Другими словами, цель диспетчеризации методов состоит в том, чтобы программа сообщала процессору, где он может найти исполняемый код конкретного метода в памяти.

Диспетчеризация происходит каждый раз, когда вызывается метод:

<img src="https://habrastorage.org/getpro/habr/upload_files/a12/221/b3c/a12221b3cd7f8d47cd3345d6d313bdfb.png" alt="alt text" width="350" height="250">

## Виды диспетчеризации

* Статическая диспетчеризация (Static dispatch) - все value type (структуры, массивы).

Статическая диспетчеризация — это **самый быстрый стиль диспетчеризации методов**. Это не только приводит к наименьшему количеству ассемблерных инструкций, но и компилятор может выполнять всевозможные умные трюки, такие как встраивание кода. Уже во время сборки компилятор знает, что вызывать и когда. Static Dispatch ускоряет работу вашего приложения, но вы не можете использовать его с подклассами. Этот тип используется в языке C и является самым быстрым.

> Примечание. Методы расширения всегда используют статическую диспетчеризацию.

* Динамическая диспетчиризация (Dynamic dispatch)

Во время выполнения программы на основании типа объекта система решает, какую именно реализацию метода вызывать. В одной стороны, это нам дает ряд преимуществ - мы можем работать с объектом производного типа как с объектом базового типа и использовать его везде, где требуется объект базового типа. Но с другой стороны, поскольку решение о выбере реализации принимается во время выполнения, то это несколько замедляет общий ход работы программы.

Для повышения производительности, задача компилятора и разработчика заключается в том, чтобы, как можно больше методов использовали статическую диспетчеризацию, в этом нам поможет следующие ключевые слова:

  I. final  не позволяет наследоваться классам (override), а методам переопределяться, что приводит к статической диспетчеризации

  II. private ограничивает видимость метода или всего класса. Отсутствие каких-либо переопределений позволяет компилятору автоматически добавлять ключевое слово final

  III. Whole Module Optimization позволяет компилятору просматривать все исходные файлы в едином модуле. Это позволяет компилятору использовать final для всех методов без переопределений.

[Данная статья Apple](https://developer.apple.com/swift/blog/?id=27) более подробно рассказывает про способы повышения производительности, уменьшая использование табличной диспетчеризации.

## Типы диспетчеризации

Перейдем к типам диспетчеризации на языке Swift. Существует три вида: 

* Direct Dispatch (статическая);

Пример:
```swift
final class MyClass() {
    func someMethod() {
        print("Direct Dispatch")
    }
}
```

* Table Dispatch (динамическая, в свою очередь, делится на Virtual Table и Witness Table);
* Message Dispatch (самая динамическая диспетчеризация);

<img src="https://hsto.org/getpro/habr/upload_files/17e/f12/078/17ef120789f74352f33c617df5996a4b.png" alt="alt text" width="600" height="250">


## История

Потоки POSIX

В конце 1980-х и начале 1990-х было несколько разных API, но в 1995 г. POSIX.1c стандартизовал потоки POSIX, позже это стало частью спецификаций SUSv3. В наше время многоядерные процессоры проникли даже в настольные ПК и смартфоны, так что даже у большинства машин есть низкоуровневая аппаратная поддержка, позволяющая им одновременно выполнять несколько потоков. В былые времена одновременное исполнение потоков на одноядерных ЦПУ было лишь впечатляюще изобретательной, но очень эффективной иллюзией.

> Posix Threads или Pthreads определяет набор типов и функций на Си.

Pthreads - самый низкий уровень управления потоками, доступные в приложении. Он дает почти прямой доступ к управлению потоками ядра OS. В swift эта бибилиотека обычно не используется из-за сложности и необходимости рабоыт с указателями. 

iOS SDK дает более простой способ управления потоками - `class Thread`. 

```swift
let thread = Thread {
  // вычисления
}
thread.start()
```

При написании многопоточных приложений требуется работать с общими данными из разных потоков и синхронизировать их. Для синхронизации потоков существуют объекты синхронизации - мьютекс (в iOS SDK они реализуются в виде [NSLock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/Concurrency.md#:~:text=NSLock%20пример) и NSRecursiveLock).

## Многопоточность

Каждое приложение состоит как минимум из 1 процесс. А процесс состоит хотя бы из 1 потока (main), о котором мы писали ранее. Все потоки разделяют общие ресурсы потока (память, файловые дескрипторы, процессорное время). У каждого потока есть свой стэк (областья память, куда сохраняются локальные переменные функции, пока эта функция сохраняется). 

Управление потоками необходимо чтобы: 1) сделать приложение быстрым, предотвратить зависающий UI, реагировать на действия пользователей без задержки; 2) параллельно обрабатывать данные; 

> Мы не можем использовать больше потоков, чем ядер у нашего процессора. 

При написании многопоточных приложений требуется работать с общими данными из разных потоков. 

## Мьютекс - NSlock

Пример, где можно использовать мьютекс NSLock:

```swift
var counter = 0 
let thread1 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Операция увеличения счетчика не [атомарно](https://github.com/eldaroid/iOSWiki/blob/master/Swift/Glossary.md#:~:text=Атомарность). Оно состоит из нескольких ша: 

```swift
let tmp = counter + 1
counter = tmp
```

Может произойти ситуация, когда оба потока могут оказаться в точке кода, производящей запись или чтение. Для исправления ситуации нужно синхронизовать обращение к счетчику. 


```swift
var counter = 0
let lock = NSLock()
let thread1 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Участок кода между `lock()` и `unlock()` называется критическая секция. NSLock позволяет вызывать `unlock()` только тому потоку с которого был вызван `lock()`.

[Deadlock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/ProblemsOfConcurrency.md#:~:text=deadlock):

```swift
let lock = NSLock()
lock.lock()
lock.lock() // deadlock()
```

## Threads in Xcode

Во время отладки существуют встроенные команды упрощющие понимание деталей текущего потока. 

<img src="https://codeswift.ru/wp-content/uploads/2022/02/12.png" alt="alt text" width="1000" height="350">

```swift
// команды для печати
po Thread.isMainThread
po Thread.isMultiThreaded()
po Thread.current
po Thread.main
```
## Grand Central Dispatch (GCD)

1. - [x] [!!! GCD queues: serial and concurrent](https://www.hapq.me/gcd-queues/)

GCD - технология управления многопоточность на базе паттерна пулл потоков. Вместо того чтобы программист сам создавал и управлял потоками за него это делает система. GCD вводит понятие очередь исполнения, представлена классом `DispatchQueue`, где очередь - список задач, которые необходимо выполнить.

> DispatchQueue - объект, который управляет выполнением задач последовательно (serial) или одновременно (concurrent) методом FIFO в основном потоке (sync) вашего приложения или в фоновом потоке (async). 

Пример фонового потока (async): 

```swift
let queue = DispatchQueue.global()
queue.async {
    // код выполнится в фоне, когда в этом потоке найдется свободный поток
}
```

Если мы хотим дождаться выполнение блока кода, то нужно выполнить задачу в основном потоке (sync), используя `sync { }`.

## Очереди в GCD бывают serial и concurrent.

Задачи в Serial (системная очередь main) очереди выполняются в очереди **одна за другой** в **одном поток**:

<img src="http://www.hapq.me/content/images/2019/12/queue2-serial.png" alt="alt text" width="850" height="650">

Задачи в Concurrent (системная очередь global) очереди выполняются **параллельно** в **нескольких потоках**:

<img src="http://www.hapq.me/content/images/2019/12/Screen-Shot-2019-12-25-at-12.03.26-PM.png" alt="alt text" width="750" height="800">

> Существует две системные очереди по умолчанию: main queue (serial - последовательная) и global queue (concurrent - параллельная с [label](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность и Память/Concurrency.md#:~:text=строка,%20необходимая%20для%20идентификации%20очереди.) глобальной очереди "com.apple.root.default-qos"). В то время как основная очередь является последовательной, глобальная очередь является параллельной.

В main очереди работает весь UI приложения, все анимации и реакции на ввод пользователя. Получая данных из базы данных или из сети необходимо перключаться на главный поток, чтобы отобразить их в UI. Лейблом главной очереди является строка com.apple.main-thread.

Помимо системных очередений, мы можем создавать собственные очереди, для этого нам необходимо создать объект типа DispatchQueue. Взглянем на декларацию инициализатора данного типа:

`convenience init(label: String, qos: DispatchQoS = .unspecified, attributes: DispatchQueue.Attributes = [], autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = .inherit, target: DispatchQueue? = nil)`

Аргументы инициализатора:

* label – строка, необходимая для идентификации очереди. Так как приложение, библиотеки и фреймворки могут создавать свои собственные очереди, необходимо придерживаться DNS стиля, например ru.popov.queue для достижения уникальности. Так же идентификатор поможет определить очередь во время отладки.

* qos – необходим для приоритизации очереди уже знакомым нам [Quality Of Service](https://developer.apple.com/documentation/dispatch/dispatchqos/qosclass).

* attributes – [атрибуты](https://developer.apple.com/documentation/dispatch/dispatchqueue/attributes), определяющие поведение очереди. Такими атрибутами могут быть .concurrent, определяющий очередь, как параллельную или .initiallyInactive, определяющий очередь неактивной, до тех пор, пока не будет вызван метод очереди activate().

* autoreleaseFrequency – частота автоосвобождения объебктов очереди. (см. [DispatchQueue.AutoreleaseFrequency](https://developer.apple.com/documentation/dispatch/dispatchqueue/autoreleasefrequency))

* target – таргет очереди, в которой будут выполняться задачи. Таким образом возможно перенаправить выполнение задач на очередь, переданную в данный аргумент.

Создание serial очереди: `let serialQueue = DispatchQueue(label: "ru.popov.serial-queue")`.

В качестве единственного аргумента для вызова метода global() требует передать уже знакомый нам QoS. Таким образом мы можем использовать очередь с учетом приоритета текущей задачи. Освежим память и еще раз взглянем на [qos](https://developer.apple.com/documentation/dispatch/dispatchqos/qosclass), только уже через призму GCD. Фреймворк Dispatch имеет собственное перечисление приоритетов. Названия и задачи приоритетов совпадают с qos из Thread и pthread api:

```swift
public enum QoSClass {
    // наивысший приоритет
    // Для задач взаимодействия с пользователем в данный момент и результат выполнения необходимо получить как можно скорее
    // Откладывать эти задачи приведет к видимым лагам
    // Н/р: обработка изображений с камеры в реальном времени
    case userInteractive
    
    // ниже приорите
    
    case userInitiated
    
    // самый низкий приоритет
    case background
    case utility
    case `default`
}
```







