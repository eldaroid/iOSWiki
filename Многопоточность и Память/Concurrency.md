 # Многопоточность
 
1. [Dispatch Queues](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW28)
2. [Углубленный анализ оптимизации производительности Swift](https://russianblogs.com/article/764556451/)
 
## Диспетчеризация

Поток можно считать меньшей единицей выполнения приложения. Каждому приложению принадлежит минимум один поток, который называется основным (main thread). Этот поток запускается операционной системой, когда вызывается метод main() приложения; это происходит при старте приложения. Заметьте, что более-менее одно и то же происходит на всех поддерживаемых платформах — как работающих на мощных компьютерах, так и на устройствах под управлением Windows Phone с ограниченными вычислительными ресурсами.

> Объект, отвечающий за управление очередью, называется **диспетчером потока** (thread’s dispatcher)

При вызове какого-либо метода операция добавляется в очередь. Каждая операция выполняется последовательно, в соответствии с порядком, в котором она была добавлена в очередь (хотя на порядок выполнения операций можно повлиять, назначив им приоритеты).

При необходимости приложение может запускать новые потоки — как явным образом в коде, так и неявным, с помощью некоторых библиотек или ОС. В основном цель запуска нового потока — выполнение какой-либо операции (или ожидание результата этой операции) без блокирования остальной части приложения.

> Диспетчеризацией методов называют процесс поиска адреса инструкций, которые нужно выполнить CPU при вызове определенного метода (какую системе имплементацию метода вызвать)

Другими словами, цель диспетчеризации методов состоит в том, чтобы программа сообщала процессору, где он может найти исполняемый код конкретного метода в памяти.

Диспетчеризация происходит каждый раз, когда вызывается метод:

<img src="https://habrastorage.org/getpro/habr/upload_files/a12/221/b3c/a12221b3cd7f8d47cd3345d6d313bdfb.png" alt="alt text" width="350" height="250">

## Виды диспетчеризации

* Статическая диспетчеризация (Static dispatch) - все value type (структуры, массивы).

Статическая диспетчеризация — это **самый быстрый стиль диспетчеризации методов**. Это не только приводит к наименьшему количеству ассемблерных инструкций, но и компилятор может выполнять всевозможные умные трюки, такие как встраивание кода. Уже во время сборки компилятор знает, что вызывать и когда. Static Dispatch ускоряет работу вашего приложения, но вы не можете использовать его с подклассами. Этот тип используется в языке C и является самым быстрым.

> Примечание. Методы расширения всегда используют статическую диспетчеризацию.

* Динамическая диспетчиризация (Dynamic dispatch)

Во время выполнения программы на основании типа объекта система решает, какую именно реализацию метода вызывать. В одной стороны, это нам дает ряд преимуществ - мы можем работать с объектом производного типа как с объектом базового типа и использовать его везде, где требуется объект базового типа. Но с другой стороны, поскольку решение о выбере реализации принимается во время выполнения, то это несколько замедляет общий ход работы программы.

Для повышения производительности, задача компилятора и разработчика заключается в том, чтобы, как можно больше методов использовали статическую диспетчеризацию, в этом нам поможет следующие ключевые слова:

  I. final  не позволяет наследоваться классам (override), а методам переопределяться, что приводит к статической диспетчеризации

  II. private ограничивает видимость метода или всего класса. Отсутствие каких-либо переопределений позволяет компилятору автоматически добавлять ключевое слово final

  III. Whole Module Optimization позволяет компилятору просматривать все исходные файлы в едином модуле. Это позволяет компилятору использовать final для всех методов без переопределений.

[Данная статья Apple](https://developer.apple.com/swift/blog/?id=27) более подробно рассказывает про способы повышения производительности, уменьшая использование табличной диспетчеризации.



## Типы диспетчеризации

Перейдем к типам диспетчеризации на языке Swift. Существует три вида: 

* Direct Dispatch (статическая);

Пример:
```swift
final class MyClass() {
    func someMethod() {
        print("Direct Dispatch")
    }
}
```

* Table Dispatch (динамическая, в свою очередь, делится на Virtual Table и Witness Table);
* Message Dispatch (самая динамическая диспетчеризация);

<img src="https://hsto.org/getpro/habr/upload_files/17e/f12/078/17ef120789f74352f33c617df5996a4b.png" alt="alt text" width="550" height="250">


## История

Потоки POSIX

В конце 1980-х и начале 1990-х было несколько разных API, но в 1995 г. POSIX.1c стандартизовал потоки POSIX, позже это стало частью спецификаций SUSv3. В наше время многоядерные процессоры проникли даже в настольные ПК и смартфоны, так что даже у большинства машин есть низкоуровневая аппаратная поддержка, позволяющая им одновременно выполнять несколько потоков. В былые времена одновременное исполнение потоков на одноядерных ЦПУ было лишь впечатляюще изобретательной, но очень эффективной иллюзией.

> Posix Threads или Pthreads определяет набор типов и функций на Си.

Pthreads - самый низкий уровень управления потоками, доступные в приложении. Он дает почти прямой доступ к управлению потоками ядра OS. В swift эта бибилиотека обычно не используется из-за сложности и необходимости рабоыт с указателями. 

IOS SDK дает более простой способ управления потоками - class Thread. 

```swift
let thread = Thread {
  // вычисления
}
thread.start()
```

## Многопоточность

Каждое приложение состоит как минимум из 1 процесс. А процесс состоит хотя бы из 1 потока (main), о котором мы писали ранее. Все потоки разделяют общие ресурсы потока (память, файловые дескрипторы, процессорное время). У каждого потока есть свой стэк (областья память, куда сохраняются локальные переменные функции, пока эта функция сохраняется). 

Управление потоками необходимо чтобы: 1) сделать приложение быстрым, предотвратить зависающий UI, реагировать на действия пользователей без задержки; 2) параллельно обрабатывать данные; 

Мы не можем использовать больше потоков, чем ядер у нашего процессора. 
