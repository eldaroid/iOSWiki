 # Многопоточность
 
1. [Dispatch Queues](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW28)
2. [Углубленный анализ оптимизации производительности Swift](https://russianblogs.com/article/764556451/)
 
## Диспетчеризация

Поток можно считать меньшей единицей выполнения приложения. Каждому приложению принадлежит минимум один поток, который называется основным (main thread). Этот поток запускается операционной системой, когда вызывается метод main() приложения; это происходит при старте приложения. Заметьте, что более-менее одно и то же происходит на всех поддерживаемых платформах — как работающих на мощных компьютерах, так и на устройствах под управлением Windows Phone с ограниченными вычислительными ресурсами.

> Объект, отвечающий за управление очередью, называется **диспетчером потока** (thread’s dispatcher)

При вызове какого-либо метода операция добавляется в очередь. Каждая операция выполняется последовательно, в соответствии с порядком, в котором она была добавлена в очередь (хотя на порядок выполнения операций можно повлиять, назначив им приоритеты).

При необходимости приложение может запускать новые потоки — как явным образом в коде, так и неявным, с помощью некоторых библиотек или ОС. В основном цель запуска нового потока — выполнение какой-либо операции (или ожидание результата этой операции) без блокирования остальной части приложения.

> Диспетчеризацией методов называют процесс поиска адреса инструкций, которые нужно выполнить CPU при вызове определенного метода (какую системе имплементацию метода вызвать)

Другими словами, цель диспетчеризации методов состоит в том, чтобы программа сообщала процессору, где он может найти исполняемый код конкретного метода в памяти.

Диспетчеризация происходит каждый раз, когда вызывается метод:

<img src="https://habrastorage.org/getpro/habr/upload_files/a12/221/b3c/a12221b3cd7f8d47cd3345d6d313bdfb.png" alt="alt text" width="350" height="250">

## Виды диспетчеризации

* Статическая диспетчеризация (Static dispatch) - все value type (структуры, массивы).

Статическая диспетчеризация — это **самый быстрый стиль диспетчеризации методов**. Это не только приводит к наименьшему количеству ассемблерных инструкций, но и компилятор может выполнять всевозможные умные трюки, такие как встраивание кода. Уже во время сборки компилятор знает, что вызывать и когда. Static Dispatch ускоряет работу вашего приложения, но вы не можете использовать его с подклассами. Этот тип используется в языке C и является самым быстрым.

> Примечание. Методы расширения всегда используют статическую диспетчеризацию.

* Динамическая диспетчиризация (Dynamic dispatch)

Во время выполнения программы на основании типа объекта система решает, какую именно реализацию метода вызывать. В одной стороны, это нам дает ряд преимуществ - мы можем работать с объектом производного типа как с объектом базового типа и использовать его везде, где требуется объект базового типа. Но с другой стороны, поскольку решение о выбере реализации принимается во время выполнения, то это несколько замедляет общий ход работы программы.

Для повышения производительности, задача компилятора и разработчика заключается в том, чтобы, как можно больше методов использовали статическую диспетчеризацию, в этом нам поможет следующие ключевые слова:

  I. final  не позволяет наследоваться классам (override), а методам переопределяться, что приводит к статической диспетчеризации

  II. private ограничивает видимость метода или всего класса. Отсутствие каких-либо переопределений позволяет компилятору автоматически добавлять ключевое слово final

  III. Whole Module Optimization позволяет компилятору просматривать все исходные файлы в едином модуле. Это позволяет компилятору использовать final для всех методов без переопределений.

[Данная статья Apple](https://developer.apple.com/swift/blog/?id=27) более подробно рассказывает про способы повышения производительности, уменьшая использование табличной диспетчеризации.

## Типы диспетчеризации

Перейдем к типам диспетчеризации на языке Swift. Существует три вида: 

* Direct Dispatch (статическая);

Пример:
```swift
final class MyClass() {
    func someMethod() {
        print("Direct Dispatch")
    }
}
```

* Table Dispatch (динамическая, в свою очередь, делится на Virtual Table и Witness Table);
* Message Dispatch (самая динамическая диспетчеризация);

<img src="https://hsto.org/getpro/habr/upload_files/17e/f12/078/17ef120789f74352f33c617df5996a4b.png" alt="alt text" width="600" height="250">


## История

Потоки POSIX

В конце 1980-х и начале 1990-х было несколько разных API, но в 1995 г. POSIX.1c стандартизовал потоки POSIX, позже это стало частью спецификаций SUSv3. В наше время многоядерные процессоры проникли даже в настольные ПК и смартфоны, так что даже у большинства машин есть низкоуровневая аппаратная поддержка, позволяющая им одновременно выполнять несколько потоков. В былые времена одновременное исполнение потоков на одноядерных ЦПУ было лишь впечатляюще изобретательной, но очень эффективной иллюзией.

> Posix Threads или Pthreads определяет набор типов и функций на Си.

Pthreads - самый низкий уровень управления потоками, доступные в приложении. Он дает почти прямой доступ к управлению потоками ядра OS. В swift эта бибилиотека обычно не используется из-за сложности и необходимости рабоыт с указателями. 

iOS SDK дает более простой способ управления потоками - `class Thread`. 

```swift
let thread = Thread {
  // вычисления
}
thread.start()
```

При написании многопоточных приложений требуется работать с общими данными из разных потоков и синхронизировать их. Для синхронизации потоков существуют объекты синхронизации - мьютекс (в iOS SDK они реализуются в виде [NSLock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/Concurrency.md#:~:text=NSLock%20пример) и NSRecursiveLock).

## Многопоточность

Каждое приложение состоит как минимум из 1 процесс. А процесс состоит хотя бы из 1 потока (main), о котором мы писали ранее. Все потоки разделяют общие ресурсы потока (память, файловые дескрипторы, процессорное время). У каждого потока есть свой стэк (областья память, куда сохраняются локальные переменные функции, пока эта функция сохраняется). 

Управление потоками необходимо чтобы: 1) сделать приложение быстрым, предотвратить зависающий UI, реагировать на действия пользователей без задержки; 2) параллельно обрабатывать данные; 

> Мы не можем использовать больше потоков, чем ядер у нашего процессора. 

При написании многопоточных приложений требуется работать с общими данными из разных потоков. 

## Мьютекс - NSlock

Пример, где можно использовать мьютекс NSLock:

```swift
var counter = 0 
let thread1 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Операция увеличения счетчика не [атомарно](https://github.com/eldaroid/iOSWiki/blob/master/Swift/Glossary.md#:~:text=Атомарность). Оно состоит из нескольких ша: 

```swift
let tmp = counter + 1
counter = tmp
```

Может произойти ситуация, когда оба потока могут оказаться в точке кода, производящей запись или чтение. Для исправления ситуации нужно синхронизовать обращение к счетчику. 


```swift
var counter = 0
let lock = NSLock()
let thread1 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Участок кода между `lock()` и `unlock()` называется критическая секция. NSLock позволяет вызывать `unlock()` только тому потоку с которого был вызван `lock()`.

[Deadlock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/ProblemsOfConcurrency.md#:~:text=deadlock):

```swift
let lock = NSLock()
lock.lock()
lock.lock() // deadlock()
```

## Threads in Xcode

Во время отладки существуют встроенные команды упрощющие понимание деталей текущего потока. 

<img src="https://codeswift.ru/wp-content/uploads/2022/02/12.png" alt="alt text" width="1100" height="300">

```swift
// команды для печати
po Thread.isMainThread
po Thread.isMultiThreaded()
po Thread.current
po Thread.main
```
## Grand Central Dispatch (GCD)

1. - [x] [!!! GCD queues: serial and concurrent](https://www.hapq.me/gcd-queues/)
2. - [x] [Про многопоточность 2. GCD](https://habr.com/ru/post/578752/)

GCD - технология управления многопоточность на базе паттерна пулл потоков. Вместо того чтобы программист сам создавал и управлял потоками за него это делает система. GCD вводит понятие очередь исполнения, представлена классом `DispatchQueue`, где очередь - список задач, которые необходимо выполнить.

> DispatchQueue - объект, который управляет выполнением задач последовательно (serial) или одновременно (concurrent) методом FIFO в основном потоке (sync) вашего приложения или в фоновом потоке (async). 

Пример фонового потока (async): 

```swift
let queue = DispatchQueue.global()
queue.async {
    // код выполнится в фоне, когда в этом потоке найдется свободный поток
}
```

Если мы хотим дождаться выполнение блока кода, то нужно выполнить задачу в основном потоке (sync), используя `sync { }`.

Наглядный пример sync и async:

<details><summary>Open</summary>
<p>
 
Существует два основных способа взаимодействия с очередями - sync и async. Данные способы подразумевают под собой методы, в которые мы будем передавать наши задачи в виде замыканий.

<details><summary>Sync</summary>
<p> 
 
**sync** – метод, позволяющий выполнять задачи синхронно по отношению к вызывающей очереди. Сперва взглянем на декларацию метода:

```swift
public func sync(execute block: () -> Void)
```
 
Как это работает? Представим, что у нас есть 7 задач, которые нам необходимо выполнить последовательно. Задачи в нашем случае представлены в виде функций:

```swift
func task1() {
    print(1)
}

func task2() {
    print(2)
}

func task3() {
    print(3)
}

func task4() {
    print(4)
}

func task5() {
    print(5)
}

func task6() {
    print(6)
}

func task7() {
    print(7)
}
```

Выполним эти задачи:

```swift
task1()
task2()
task3()
task4()
task5()
task6()
task7()
```
 
Все выполняемые задачи by default будут выполнятся в главном потоке, а если точнее на главной очереди:
 
<img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/867/38b/2d6/86738b2d6e5e0fefe6280a821d83b6cd.png" alt="alt text" width="700" height="300">

Ничего сложного, каждая задача дожидается своей очереди в порядке их вызова, так как главная очередь является последовательной. Усложним задачу и выполним task3 на другой serial очереди. Для этого нам необходимо создать новую последовательную очередь:
 
`let serialQueue = DispatchQueue(label: "ru.popov.serial-queue")` 

и увести выполнение task3 на только что созданную очередь. Для этого мы воспользуемся методом sync:
 
```swift
task1()
task2()
serialQueue.sync(execute: task3)
task4()
task5()
task6()
task7()
```
 
Визуализируем:
 
<img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e69/886/80a/e6988680a9f6bccebfc1971d9a636f3a.png" alt="alt text" width="700" height="600">
 
Как мы можем видеть, задача task3 действительно выполняется на очереди serialQueue, в то время как основной поток ожидает ее выполнения. В этом и заключется суть метода sync, вызывающая очередь (в нашем случае main) будет ожидать до тех пор, пока выполняющая очередь (в нашем случае serialQueue) не вернет управление. Но что делать, если мы не хотим, чтобы вызывающая очередь дожидалась выполнения задачи task3? Для таких целей существует метод async.

</p>
</details>

<details><summary>Async</summary>
<p> 
 
**async** – метод, позволяющий выполнять задачи асинхронно по отношению к текущей очереди
 
Декларация async метода:
 
`public func async(group: DispatchGroup? = nil, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention(block) () -> Void)`

Как мы можем видеть, метод async требует передать большее количество аргументов, но сейчас нас интересует лишь execute work

Мы воспользуемся примером с семью задачами, но заменим вызов метода sync на async:
 
```swift
task1()
task2()
serialQueue.async(execute: task3)
task4()
task5()
task6()
task7()
```
 
И снова визуализируем:

<img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/9d9/33c/7dd/9d933c7dd1c9d9afa0c6c82d0a6963b9.png" alt="alt text" width="700" height="600">
 
Как мы можем видеть, задача task3 все так же выполняется на очереди serialQueue, но при этом main не дожидается ее выполнения и продолжает свою работу асинхронно. В этом и заключется суть метода async, вызывающая очередь (в нашем случае main) не будет ожидать выполнения задач на выполняющей очереди (в нашем случае serialQueue), а сразу же приступит к выполнения стоящих в очереди задач.
 
</p>
</details>
 
</p>
</details>

## Типы очередей - serial/concurrent

Задачи в Serial (системная очередь main) очереди выполняются в очереди **одна за другой** в **одном поток**:

<img src="http://www.hapq.me/content/images/2019/12/queue2-serial.png" alt="alt text" width="850" height="650">

Задачи в Concurrent (системная очередь global) очереди выполняются **параллельно** в **нескольких потоках**:

<img src="http://www.hapq.me/content/images/2019/12/Screen-Shot-2019-12-25-at-12.03.26-PM.png" alt="alt text" width="750" height="800">

### Context switch in concurrent

Поговорим немного про ресурсозатратность. Concurrent очередь достигает возможность параллить задачи благодаря множеству потоков, на которых она выполняет эти самые задачи. У всего есть своя цена и concurrent queue не исключение, процесс переключения между потоками является одним из самых ресурсозатратных в многопоточной среде, а имя ему context switch.

Переключение контекста (англ. context switch) — в многозадачных ОС и средах - процесс прекращения выполнения процессором одной задачи (процесса, потока, нити) с сохранением всей необходимой информации и состояния, необходимых для последующего продолжения с прерванного места, и восстановления и загрузки состояния задачи, к выполнению которой переходит процессор.

Не смотря на то, что context switch оптимизирован на уровне ОС, он все равно требует больших вычислительных ресурсов. Эти ресурсы в основном тратятся на сохранение контекста текущего процесса (что на самом деле задействовано в переключении контекста, зависит от архитектуры, операционной системы и количества совместно используемых ресурсов). В отличии от concurrent, serial очередь использует единственный поток, таким образом выполнение задач в очереди не приводит к context switch.

## Создание очередей

> Существует две системные очереди по умолчанию: main queue (serial - последовательная) и global queue (concurrent - параллельная с [label](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/Concurrency.md#:~:text=строка,%20необходимая%20для%20идентификации%20очереди.) глобальной очереди "com.apple.root.default-qos"). В то время как основная очередь является последовательной, глобальная очередь является параллельной.

В main очереди работает весь UI приложения, все анимации и реакции на ввод пользователя. Получая данных из базы данных или из сети необходимо перключаться на главный поток, чтобы отобразить их в UI. Лейблом главной очереди является строка com.apple.main-thread.

Помимо системных очередений, мы можем создавать собственные очереди, для этого нам необходимо создать объект типа DispatchQueue. Взглянем на декларацию инициализатора данного типа:

`convenience init(label: String, qos: DispatchQoS = .unspecified, attributes: DispatchQueue.Attributes = [], autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = .inherit, target: DispatchQueue? = nil)`

Аргументы инициализатора:

* label – строка, необходимая для идентификации очереди. Так как приложение, библиотеки и фреймворки могут создавать свои собственные очереди, необходимо придерживаться DNS стиля, например ru.popov.queue для достижения уникальности. Так же идентификатор поможет определить очередь во время отладки.

* qos – необходим для приоритизации очереди уже знакомым нам [Quality Of Service](https://developer.apple.com/documentation/dispatch/dispatchqos/qosclass).

* attributes – [атрибуты](https://developer.apple.com/documentation/dispatch/dispatchqueue/attributes), определяющие поведение очереди. Такими атрибутами могут быть .concurrent, определяющий очередь, как параллельную или .initiallyInactive, определяющий очередь неактивной, до тех пор, пока не будет вызван метод очереди activate().

* autoreleaseFrequency – частота автоосвобождения объебктов очереди. (см. [DispatchQueue.AutoreleaseFrequency](https://developer.apple.com/documentation/dispatch/dispatchqueue/autoreleasefrequency))

* target – таргет очереди, в которой будут выполняться задачи. Таким образом возможно перенаправить выполнение задач на очередь, переданную в данный аргумент.

### Пример создния очереди

Создание main serial очереди: `let demoSerialQueue = DispatchQueue(label: "ru.popov.serial-queue", qos: .utility)`.

В качестве единственного аргумента для вызова метода global() требует передать уже знакомый нам QoS. Таким образом мы можем использовать очередь с учетом приоритета текущей задачи. Освежим память и еще раз взглянем на [qos](https://developer.apple.com/documentation/dispatch/dispatchqos/qosclass), только уже через призму GCD. Фреймворк Dispatch имеет собственное перечисление приоритетов. 

Пример: `let demoConcurrentQueue = DispatchQueue(label: "ru.popov.concurrent-queue", qos: .utility, attributes: .concurrent)` или `let demoGlobalQueue = DispatchQueue.global(qos: .utility)`

Названия и задачи приоритетов совпадают с qos из Thread и pthread api:

```swift
public enum QoSClass {
    // наивысший приоритет
    // Для задач взаимодействия с пользователем в данный момент и результат выполнения необходимо получить как можно скорее
    // Откладывать эти задачи приведет к видимым лагам
    // Н/р: обработка изображений с камеры в реальном времени
    case userInteractive
    
    
    // Задачи, которые запустил пользователь и их выполнения необходимо дождаться, но не мгновенно
    // Н/р: обновление данные после pull to refresh
    // Такая задача может выполняться несколько секунд
    case userInitiated
    
    // очередь, которая создает, когда в qos мы ничего не передали
    case `default`
    
    // Пользователь не запрашивал выполнение задачи 
    // и ее выполнение можно отложить
    case utility
    
    // самый низкий приоритет
    // используется когда нам совсем не критично время выполнение задачи
    case background
}
```







