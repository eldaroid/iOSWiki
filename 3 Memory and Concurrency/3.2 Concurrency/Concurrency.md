 # Многопоточность
 
1. [Углубленный анализ оптимизации производительности Swift](https://russianblogs.com/article/764556451/)
2. [iOS Concurrency — Underlying Truth](https://chetan-aggarwal.medium.com/ios-concurrency-underlying-truth-1021a0bb2a98)
3. [Concurrent Programming](https://www.oreilly.com/library/view/high-performance-ios/9781491910993/ch04.html)
4. [Process, Threads and Queues in iOS](https://www.tirupatibalan.com/2019/04/01/process-threads-queues-in-ios.html)
5. [Multithreading and Concurrency](https://github.com/sashakid/ios-guide/blob/master/Main/10_multithreading_concurrency.md)

## История

Потоки POSIX

В конце 1980-х и начале 1990-х было несколько разных API, но в 1995 г. POSIX.1c стандартизовал потоки POSIX, позже это стало частью спецификаций SUSv3. В наше время многоядерные процессоры проникли даже в настольные ПК и смартфоны, так что даже у большинства машин есть низкоуровневая аппаратная поддержка, позволяющая им одновременно выполнять несколько потоков. В былые времена одновременное исполнение потоков на одноядерных ЦПУ было лишь впечатляюще изобретательной, но очень эффективной иллюзией.

## Многопоточность

В мире операционных систем существуют две сущности, где запускаются наши программы (некие капсулы запуска прогармм) - **процессы (изолированы друг от друга)**,**потоки (thread) (обмениваются данными почти бесплатно)**. Каждое приложение состоит как минимум из 1 процесс - чаще всего только один. А процесс состоит хотя бы из 1 потока (main). 

![](https://www.w3.org/People/Frystyk/thesis/MultiStackThread.gif)


## Процесс

> Процесс — это исполняемый **экземпляр приложения (path of execution. Н/р: main())**, создается автоматически вызывая метод fork(). Важно отметить, что поток может делать все то же, что и процесс. Но поскольку процесс может состоять из нескольких потоков, поток можно считать «облегченным» процессом.

## Поток

Поток можно считать меньшей единицей выполнения приложения. Каждому приложению принадлежит минимум один поток, который называется основным (main thread). Этот поток запускается операционной системой, когда вызывается метод main() приложения; это происходит при старте приложения. Заметьте, что более-менее одно и то же происходит на всех поддерживаемых платформах — как работающих на мощных компьютерах, так и на устройствах под управлением Windows Phone с ограниченными вычислительными ресурсами.

При вызове какого-либо метода операция добавляется в очередь. Каждая операция выполняется последовательно, в соответствии с порядком, в котором она была добавлена в очередь (хотя на порядок выполнения операций можно повлиять, назначив им приоритеты).

Все потоки разделяют общие ресурсы потока (память, файловые дескрипторы, процессорное время). У каждого потока есть свой стэк (областья память, куда сохраняются локальные переменные функции, пока эта функция сохраняется). 

Управление потоками необходимо чтобы: 1) сделать приложение быстрым, предотвратить зависающий UI, реагировать на действия пользователей без задержки; 2) параллельно обрабатывать данные; 

> Мы не можем использовать больше потоков, чем ядер у нашего процессора. 

При написании многопоточных приложений требуется работать с общими данными из разных потоков. 

### Thread

> Posix Threads или Pthreads определяет набор типов и функций на Си.

Pthreads - самый низкий уровень управления потоками, доступные в приложении. Он дает почти прямой доступ к управлению потоками ядра OS. В swift эта бибилиотека обычно не используется из-за сложности и необходимости рабоыт с указателями. 

iOS SDK дает более простой способ управления потоками - `class Thread`. 

```swift
let thread = Thread {
  // вычисления
}
thread.start()
```

> Объект, отвечающий за управление очередью, называется **диспетчером потока** (thread’s dispatcher)

## Очередь

Говоря о параллелизме в Swift, обычно имеют в виду очереди, которые содержат в себе thread (потоки  ).

Очередь — это массив задач, каждая из которых начинает выполнение в порядке их добавления.

Существует два типа очередей: последовательные(serial) и параллельные(concurrent).

1) В последовательной (serial) очереди задачи выполняются одна за другой. Следующая задача не будет запущена, пока предыдущая не будет завершена.

> Одновременно может выполняться только одна задача   

2) В параллельной (concurrent) очереди задачи также выполняются одна за другой. Однако каждая задача выполняется в отдельном потоке, и очередь не ждет, пока предыдущая задача запустит следующую. Следующая задача запускается немедленно, если ресурсов достаточно для создания еще одного потока.

![](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kLEmTBWRe-IWs3lRulogA.png)

## Sync Async

1. [Swift. Concurrency](https://maxim-kryloff.medium.com/swift-concurrency-810fdbe0b248)

![SyncAsync](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tw7NVWb3NxWo6SSOBl7RGg.png)

## Разница между синхронными и асинхронными задачами, однопоточностью и многопоточностью

Ниже описаны термины в привязке к GCD, но с небольшими изменениями они верны и для программирования в целом.

Синхронная операция начинает выполнятся сразу при вызове, блокируя текущий поток. Выполняется в текущем потоке. 

Асинхронная операция ставит задачу в очередь выполнения, продолжает выполнение кода, из которого вызвана задача. Если очередь однопоточная, то задача будет выполнятся после выполнения всех задач, которые уже поставлены в очередь, если многопоточная - возможно ее выполнение в другом потоке.

Нужно запомнить, что синхронность-асинхронность и однопоточность-многопоточность две пары разных характеристить, и одни не зависят от других (и синхронность и асинхронность могут работать как в однопоточной среде, так и в многопоточной)


## Способы достижения многопоточности в iOS и macOS

Существует три способа достижения параллелизма в iOS:

* Потоки (threads);
* [GCD](./GCD.md);
* NSOperationQueue;

> Последующие методы работы многопоточности в iOS - это всего лишь удобные обертки над unix потоками: судя по стеку вызовов NSThread использует pthread. Насчет dispatch он использует darwin-libpthread

Недостатком потоков является то, что они немасштабируемы для разработчика. Вы должны решить, сколько потоков нужно создать и изменять их число динамически в соответствии с условиями. Кроме того, приложение принимает на себя большую часть затрат, связанных с созданием и встраиванием потоков, которые оно использует.

Поэтому в macOS и iOS предпочтительно использовать асинхронный подход к решению проблемы параллелизма, а не полагаться на потоки.

Одной из технологий асинхронного запуска задач является Grand Central Dispatch (GCD), которая отводит управление потоками до уровня системы. Все, что разработчик должен сделать, это определить выполняемые задачи и добавить их в соответствующую очередь отправки. GCD заботится о создании необходимых потоков и время для работы в этих потоках.

Все `dispatch queues` представляют собой структуры данных FIFO, поэтому задачи всегда запускаются в том же порядке, в котором они добавлены.

В отличие от dispatch queue очереди операций (NSOperation Queue) не ограничиваются выполнением задач в порядке FIFO и поддерживают создание сложных графиков выполнения заказов для ваших задач.

## Что такое мьютекс (mutex)?

> Мьютекс — это семафор, работающий с системой блокировки

При написании многопоточных приложений требуется работать с общими данными из разных потоков и синхронизировать их. Для синхронизации потоков существуют объекты синхронизации - мьютекс (в iOS SDK они реализуются в виде [NSLock](https://github.com/eldaroid/iOSWiki/blob/master/Многопоточность%20и%20Память/Concurrency.md#:~:text=Мьютекс%20-%20NSlock) и NSRecursiveLock).

Мьютекс является одним из видов семафора, который предоставляет доступ одновременно только одному потоку. Если мьютекс используется и другой поток пытается получить его, что поток блокируется до тех пор, пока мьютекс не освободится от своего первоначального владельца. Если несколько потоков соперничают за одни и те же мьютексы, только одному будет разрешен к нему доступ.

## Что такое семафор (semafor)?

Семафор позволяет выполнять какой-либо участок кода одновременно только конкретному количеству потоков. В основе семафора лежит счетчик, который и определяет, можно ли выполнять участок кода текущему потоку или нет. Если счетчик больше нуля — поток выполняет код, в противном случае — нет. В GCD выглядит так: semaphore_create – создание семафора (аналог sem_init)
semaphore_destroy – удаление, соответственно (аналог sem_destroy)
semaphore_wait – блокирующее ожидание на семафоре (аналог sem_wait)
semaphore_signal – освобождение семафора (аналог sem_post)

## Пример мьютекса - NSlock

Пример, где можно использовать мьютекс NSLock:

```swift
var counter = 0 
let thread1 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         counter += 1
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Операция увеличения счетчика не [атомарно](https://github.com/eldaroid/iOSWiki/blob/master/Swift/Glossary.md#:~:text=Атомарность). Оно состоит из нескольких ша: 

```swift
let tmp = counter + 1
counter = tmp
```

Может произойти ситуация, когда оба потока могут оказаться в точке кода, производящей запись или чтение. Для исправления ситуации нужно синхронизовать обращение к счетчику. 


```swift
var counter = 0
let lock = NSLock()
let thread1 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}

let thread2 = Thread {
    for _ in 0..<1000 {
         lock.lock()
         counter += 1
         lock.unlock()
    }
}
thread1.start()
thread2.start()

// counter < 2000
```

Участок кода между `lock()` и `unlock()` называется критическая секция. NSLock позволяет вызывать `unlock()` только тому потоку с которого был вызван `lock()`.

[Deadlock](/3%20Memory%20and%20Concurrency/3.2%20Concurrency/ProblemsOfConcurrency.md):

```swift
let lock = NSLock()
lock.lock()
lock.lock() // deadlock()
```

Исправление deadlock:

```swift
let lock = NSRecursiveLock()
lock.lock()
lock.lock()
lock.unlock()
lock.unlock()
```

## Threads in Xcode

Во время отладки существуют [встроенные команды](https://codeswift.ru/wp-content/uploads/2022/02/12.png) упрощающие понимание деталей текущего потока. 

```swift
// команды для печати
po Thread.isMainThread
po Thread.isMultiThreaded()
po Thread.current
po Thread.main
```
