## Functional Programming (FP)

1. [Функциональное программирование для всех](https://habr.com/ru/articles/142351/)

## История

Функциональное программирование — это практическая реализация идей [Алонзо Чёрча]. 

Совместно с другими учёными Алонзо разработал формальную систему названную Лямбда-исчислением. Система по сути была языком программирования для одной из воображаемых машин. Она была основана на функциях, которые принимают в качестве аргументов функции, и возвращают функцию. Такая функция была обозначена греческой буквой Лямбда, что дало название всей системе.

> Каждый раз, когда вы слышите «лямбда» в разговоре о функциональном программировании, переводите это про себя в «функцию». А греческая буква используется для удобства математической записи.

Система Чёрча интересна тем, что в конечном итоге она преобразовалась в реальный язык программирования `List Processing language (Lisp)`, исполняемый компьютером. Это произошло в 1958 году, что делает Lisp вторым (или третьим) по старшинству языком программирования, [используемым до сих пор](https://typeable.io/blog/2021-10-04-lisp-usage).

Так началось FP на [функциональных языках](../../Languages/TypesOfLanguages.md) Lisp/Haskel.

Независимо от Алонзо, Алан Тьюринг проводил подобное исследование. Он разработал другую формальную систему (которую сейчас называют Машиной Тьюринга), и используя её пришёл к выводам, подобным Алонзо. Позже было доказано, что машина Тьюринга и лябда-исчисление имеют [одинаковую мощность](https://cstheory.stackexchange.com/a/637).

## Функциональное программирование

Функциональное программирование — это практическая реализация идей Алонзо Чёрча. Поэтому FP — это набор идей, а не набор четких указаний. Существует много функциональных языков, и большинство из них делают одни схожие вещи по разному.

## Функции

Лямбда исчисление было придумано для изучения проблем, связанным с вычислениями. Функциональное программирование, стало быть, в первую очередь имеет дело с вычислениями, и, на удивление, использует для этого функции.

Функция — это базовый элемент FP. Функции используются почти для всего, даже для простейших расчётов. Даже переменные заменяются функциями. В функциональном программировании переменные — это просто синонимы (alias) для выражений (чтобы нам не пришлось писать всё в одну строку). Их нельзя изменять. В каждую переменную можно записать только один раз. В терминах Swift это означает, что все переменные объявляются как [final](/Swift/MethodDispatch/MethodDispatch.md) (или const если имеем дело с C++). В ФП нет не-final переменных.

> неизменяемое состояние и отсутствие побочных эффектов

### Функции First-Class (первого класса) and Higher-Order (высшего порядка)

1 ) Функции, которые оперируют функциями (принимают их в качестве аргументов) называются **функциями высшего порядка - higher-order**. Пусть это вас не пугает. Понятие функций высшего порядка почти не отличается от понятия Swift классов, которые оперируют друг другом (мы можем передавать классы в другие классы). Мы можем называть их «классы высшего порядка», но никто этим не заморачивается, потому что за Swift не стоит строгое академическое сообщество.

Наиболее распространенными функциями высшего порядка в языках FP: `filter`, `map` и `reduce`.

2 ) Функции первого класса - фича языка, позволяющая переменным присваивать ссылки на функции. То есть рассматривать функции, как любую другую переменную. Вы можете присвоить их переменным и передать их в качестве аргументов другим функциям.

По сути первого класса и высшего порядка - разные вещи, но по отдельности смысла в них не много:)

Альтернатива - указатели на функций. C и C++ используют указатель функции для имитации поведения функции высшего порядка.

## Многопоточность

В функциональной программе всё состояние хранится в стеке в виде аргументов функций, поэтому функциональная программа сразу готова к распараллеливанию без каких-либо изменений. Вам не придётся задумываться о deadlock-ах или состояниях гонки (race conditions) потому что вам не нужны блокировки! Ни один кусочек данных в функциональной программе не меняется дважды одним и тем же потоком или разными. Это означает, что вы можете легко добавить потоков к вашей программе даже не задумываясь при этом о проблемах, присущих императивным языкам.

## Каррирование

## Рекурсия

Рекурсия — это когда функция вызывает саму себя, и при этом ей нужно держать в памяти все предыдущие этапы.
