## Functional Programming (FP)

1. [Функциональное программирование для всех](https://habr.com/ru/articles/142351/)

## История

Функциональное программирование — это практическая реализация идей [Алонзо Чёрча]. 

Совместно с другими учёными Алонзо разработал формальную систему названную Лямбда-исчислением. Система по сути была языком программирования для одной из воображаемых машин. Она была основана на функциях, которые принимают в качестве аргументов функции, и возвращают функцию. Такая функция была обозначена греческой буквой Лямбда, что дало название всей системе.

> Каждый раз, когда вы слышите «лямбда» в разговоре о функциональном программировании, переводите это про себя в «функцию». А греческая буква используется для удобства математической записи.

Система Чёрча интересна тем, что в конечном итоге она преобразовалась в реальный язык программирования `List Processing language (Lisp)`, исполняемый компьютером. Это произошло в 1958 году, что делает Lisp вторым (или третьим) по старшинству языком программирования, [используемым до сих пор](https://typeable.io/blog/2021-10-04-lisp-usage).

Так началось FP на [функциональных языках](../../TypesOfLanguages.md) Lisp/Haskel.

Независимо от Алонзо, Алан Тьюринг проводил подобное исследование. Он разработал другую формальную систему (которую сейчас называют Машиной Тьюринга), и используя её пришёл к выводам, подобным Алонзо. Позже было доказано, что машина Тьюринга и лябда-исчисление имеют [одинаковую мощность](https://cstheory.stackexchange.com/a/637).

## Функциональное программирование

Функциональное программирование — это практическая реализация идей Алонзо Чёрча. Поэтому FP — это набор идей, а не набор четких указаний. Существует много функциональных языков, и большинство из них делают одни схожие вещи по разному.

## Функции

Лямбда исчисление было придумано для изучения проблем, связанным с вычислениями. Функциональное программирование, стало быть, в первую очередь имеет дело с вычислениями, и, на удивление, использует для этого функции.

Функция — это базовый элемент FP. Функции используются почти для всего, даже для простейших расчётов. Даже переменные заменяются функциями. В функциональном программировании переменные — это просто синонимы (alias) для выражений (чтобы нам не пришлось писать всё в одну строку). Их нельзя изменять. В каждую переменную можно записать только один раз. В терминах Swift это означает, что все переменные объявляются как [final](/Swift/MethodDispatch/MethodDispatch.md) (или const если имеем дело с C++). В ФП нет не-final переменных.

> неизменяемое состояние и отсутствие побочных эффектов

### Функции First-Class (первого класса) and Higher-Order (высшего порядка)

1 ) Функции, которые оперируют функциями (принимают их в качестве аргументов) называются **функциями высшего порядка - higher-order**. Пусть это вас не пугает. Понятие функций высшего порядка почти не отличается от понятия Swift классов, которые оперируют друг другом (мы можем передавать классы в другие классы). Мы можем называть их «классы высшего порядка», но никто этим не заморачивается, потому что за Swift не стоит строгое академическое сообщество.

Наиболее распространенными функциями высшего порядка в языках FP: `filter`, `map` и `reduce`.

2 ) Функции первого класса - фича языка, позволяющая переменным присваивать ссылки на функции. То есть рассматривать функции, как любую другую переменную. Вы можете присвоить их переменным и передать их в качестве аргументов другим функциям.

По сути первого класса и высшего порядка - разные вещи, но по отдельности смысла в них не много:)

Альтернатива - указатели на функций. C и C++ используют указатель функции для имитации поведения функции высшего порядка.

## Многопоточность

В функциональной программе всё состояние хранится в стеке в виде аргументов функций, поэтому функциональная программа сразу готова к распараллеливанию без каких-либо изменений. Вам не придётся задумываться о deadlock-ах или состояниях гонки (race conditions) потому что вам не нужны блокировки! Ни один кусочек данных в функциональной программе не меняется дважды одним и тем же потоком или разными. Это означает, что вы можете легко добавить потоков к вашей программе даже не задумываясь при этом о проблемах, присущих императивным языкам.

## Каррирование 

> В честь специалиста по логике Хаскелла Карри (Haskell Curry), который провёл ряд математических трюков, чтобы всё это формализовать.

В функциональном языке вам не понадобятся паттерны проектирования, потому что язык настолько [высокоуровневый](../../TypesOfLanguages.md), что вы легко начнёте программировать в концепциях, которые исключают все известные паттерны программирования.

Одним из таких паттернов является [Адаптер](/ComputerScience/Patterns/DesignPattern/Structural/Adapter.md) (чем он отличается от [Фасада](/ComputerScience/Patterns/DesignPattern/Structural/Facade.md)? Похоже, что кому-то понадобилось наштамповать побольше страниц, чтобы выполнить условия контракта). Этот паттерн оказывается ненужным если в языке есть поддержка каррирования.

Паттерн Адаптер наиболее часто применяется к «стандартной» единице абстракции в Java — классу. В функциональных языках паттерн применяется к функциям. Паттерн берёт интерфейс и преобразует его в другой интерфейс, согласно определённым требованиям. Вот пример паттерна [Адаптер](/ComputerScience/Patterns/DesignPattern/Structural/Adapter.md):

```java
int pow(int i, int j);
int square(int i)
{
    return pow(i, 2);
}
```

Этот код адаптирует интерфейс функции, возводящей число в произвольную степень, к интерфейсу функции, которая возводит число в квадрат. В аккадемических кругах этот простейший приём называется каррирование. Так как в ФП функции используются повсеместно в качестве аргументов, каррирование используется очень часто, чтобы привести функции к интерфейсу, необходимому в том или ином месте. Так как интерфейс функции — это её аргументы, то каррирование используется для уменьшения количества аргументов (как в примере выше).

Этот инструмент является встроенным в функциональные языки. Вам не нужно вручную создавать функцию, которая оборачивает оригинал. Функциональный язык сделает всё за вас. Как обычно давайте расширим наш язык, добавив в него каррирование.

```java
square = int pow(int i, 2);
```

Как видите, мы просто написали обёртку над оригинальной функцией. Вы сосредотачиваетесь на задаче, а компилятор пишет необходимый код за вас! Всё очень просто, и происходит каждый раз, когда вы хотите использовать паттерн Адаптер (обёртку).

>  В ФП каррирование как раз и представляет из себя простой и удобный способ создания обёрток

## Ленивые вычисление

Ленивые (или отложенные) вычисления — это интересная техника, которая становится возможной как только вы усвоите функциональную философию.

В [императивных языках](../Imperative/AboutImperative.md) программирования очерёдность вычисления не вызывает никаких вопросов. Поскольку каждая функция может повлиять или зависеть от внешнего состояния, то необходимо соблюдать чёткую очерёдность вызовов (последовательную).

В ФП вычислениея !не зависят от внешного состояния, поэтому функции не обязательно выполняются последовательно (в том смысле, что они могут не вызваться и не хранить значение до момента его вызова).

Haskell — это пример языка с отложенными вычислениями. В Haskell отсутствует гарантия какой-либо очередности вызовов (вообще!), потому что Haskell выполняет код по мере необходимости.

```Haskell
System.out.println("Please enter your name: ");
System.in.readLine();
```

В ленивом языке никто не гарантирует, что первая строка выполнится раньше второй!

## Бесконечность

Ленивые языки позволяют создавать бесконечные структуры данных, создание которых в строгих языках гораздо сложнее. 

Например, представьте себе последовательность Фибоначи. Очевидно, что мы не можем вычислить бесконечный список за конечное время и при этом сохранить его в памяти. 
В строгих языках, таких как Java, мы просто написали бы функцию, которая возвращает произвольный член последовательности. 
В языках подобных Haskell мы можем абстрагироваться и просто объявить бесконечный список чисел Фибоначи. Так как язык ленивый, то будут вычислены лишь необходимые части списка, которые реально используются в программе. 

Это позволяет абстрагироваться от большого числа проблем и посмотреть на них с более высокого уровня (например можно использовать функции обработки списков на бесконечных последовательностях).


## Рекурсия

Рекурсия — это когда функция вызывает саму себя, и при этом ей нужно держать в памяти все предыдущие этапы.

## Замыкания

До сих пор мы обсуждали особенности ФП в контексте «чисто» функциональных языков — языков, которые являются реализацией лямбда исчисления и не содержат особенностей, противоречащих формальной системе Чёрча. 

Хотя реализация аксиоматической системы интересна с точки зрения программирования в терминах математических выражений, это не всегда может быть применимо на практике. Многие языки предпочитают использовать элементы функциональных языков не придерживаясь строгой функциональной доктрины.
