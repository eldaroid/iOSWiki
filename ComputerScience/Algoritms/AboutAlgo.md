## Алгоритмы

1. [LeetCode Swift](https://github.com/TerryHuangHD/LeetCode-Swift#google)
2. [Видеолекции курса «Алгоритмы и структуры данных»](https://www.coursera.org/specializations/data-structures-algorithms/?utm_medium=institutions&utm_source=yandex&utm_campaign=yacademy)
3. [Алгоритмы на swift](https://github.com/sashakid/ios-guide/blob/master/Main/3_algorithms.md)
4. [Тренировки по алгоритмам от Яндекса](https://www.youtube.com/playlist?list=PL6Wui14DvQPySdPv5NUqV3i8sDbHkCKC5)

### Различают три основных вида алгоритмов:

* Линейный алгоритм – это алгоритм, в котором действия выполняются однократно и строго последовательно.

* Разветвляющийся алгоритм – это алгоритм, в котором в зависимости от условия выполняется либо одна, либо другая последовательность действий.

* Циклический алгоритм – это алгоритм, команды которого повторяются некое количество раз подряд.

### Задачи алгоритмов в программировании

**Поиск** — обработка некоторого множества данных с целью выявления подмножества данных, соответствующего критериям поиска. Все алгоритмы поиска делятся на

* поиск в неупорядоченном множестве данных;

* поиск в упорядоченном множестве данных.

* упорядоченность – наличие отсортированного ключевого поля.

**Сортировка** — упорядочение (перестановка) элементов в подмножестве данных по какому-либо критерию. Чаще всего в качестве критерия используется некоторое числовое поле, называемое ключевым. Упорядочение элементов по ключевому полю предполагает, что ключевое поле каждого следующего элемента не больше предыдущего (сортировка по убыванию). Если ключевое поле каждого последующего элемента не меньше предыдущего, то говорят о сортировке по возрастанию. Цель сортировки — облегчить последующий поиск элементов в отсортированном множестве при обработке данных.

Все алгоритмы сортировки делятся на

* алгоритмы внутренней сортировки (сортировка массивов);

* алгоритмы внешней сортировки (сортировка файлов).

Устойчивая (стабильная) сортировка — сортировка, которая не меняет относительный порядок сортируемых элементов, имеющих одинаковые ключи, по которым происходит сортировка.

### Сложность

Нашей целью является выражение ресурсных требований программ (как правило, времени выполнения, памяти) в зависимости от N с использованием математических формул, которые справедливы для большиих значений параметров. Измерение такой зависимости происходит при помощи Big O-notation.

> Другими словами (в рамках computer science): Big o показывает **верхнюю границу/отбрасывать константу ** зависимости между **входными параметрами** функции и **количеством операций** , которые выполнить процессор

Из книги [Роберт Седжвик "Фундаментальные алгоритмы на C++"](https://vk.com/wall-101965347_98371):

| Сложность | Описание | Пример | 
|------------|------------|------------|
| 1 | Большинство инструкций большинства программ выполняется один или максимум несколько раз. Если все инструкции программы обладают этим свойством, мы говорим, что время выполнения программы постоянно (constant). | |
| logN | Когда время выполнения программы описывается логарифмической (logarithmic) зависимостью, программа немного утрачивает быстродействие с ростом N. Такое время выполнения обычно характерно для программ, которые сводят крупную задачу к некоторой последовательности задач меньшего размера, уменьшая на каждом шаге размер задачи на некоторую небольшую часть. В интересующем нас диапазоне мы будем рассматривать время выполнения как величину, не превосходящую некоторое большое постоянное значение. Основание логарифма изменяет это значение, но ненамного: * когда N — тысяча, log N равно 3, если основание равно 10, либо примерно 10, если основание равно 2; * когда N равно миллиону, значения log N всего лишь удвоится. При удвоении N значение logN возрастет на постоянную ве личину, а удваивается лишь, когда N увеличится до N^2 | Двоичный (бинарный) поиск (метод деления пополам или дихотомия) |
| N |Когда время выполнения программы линейно (linear), это обычно означает, что каждый элемент ввода подвергается небольшой обработке. Когда N равно миллиону, такого же порядка и время выполнения алгоритма. Когда N удваивается, то же происходит и со временем выполнения. Эта ситуация оптимальна для алгоритма, который должен обработать N вводов (или произвести N выводов)| |
| N*logN | Время выполнения, пропорциональное .N log N имеет место, когда алгоритм решает задачу, разбивая ее на подзадачи меньших размеров, решая их неза висимо и затем объединяя решения. Из-за отсутствия подходящего прилага тельного ("линерифмический" "linerithmic") мы просто говорим, что время выполнения такого алгоритма равно N log N. Когда N равно 1 миллион, N log N возрастает примерно до 20 миллионов. Когда N удваивается, то время выполнения возрастает более чем вдвое (но не намного более) | |
| N^2 | Когда время выполнения алгоритма является квадратичным (quadratic), он полезен дляпрактического использования применительно к небольшим зада чам. Квадратичное время выполнения обычно характерно для алгоритмов, которые обрабатывают все элементы данных парами (возможно, в цикле двойного уровня вложения). Когда N равно одной тысяче, время выполне ния равно одному миллиону. Когда N удваивается, время выполнения увели чивается в четыре раза | |
| 2^N | Лишь немногие алгоритмы с экспоненциальным (exponential) временем выполнения имеют практическое применение, хотя такие алгоритмы возникают ес тественным образом при попытках решения задачи "в лоб". Когда N равно 20, время выполнения равно 1 миллиону. Когда N удваивается, время выпол нения увеличивается в четыре раза! | 
| N! | ?? | |


![BigO](https://github.com/eldaroid/pictures/blob/master/iOSWiki/Algoritms/BigONotaion.png?raw=true)

