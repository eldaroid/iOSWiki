## Реактивное программирование

1. :heavy_check_mark: [Using Combine](https://heckj.github.io/swiftui-notes/)

Zip, CombineLatest, Map, Filter with [interactive vizualization](https://rxmarbles.com/#combineLatest)

Реактивное программирование — это пример [FP-подхода](./2.2.2.1.1%20FunctionalProgramming(FP).md) к разработке пользовательского интерфейса.

Реактивное программирование — это новый и самый высокий уровень абстракции для асинхронной работы с данными.

В его основе лежит паттерн проектирования [Observer](/2%20ComputerScience/2.4%20Patterns/2.4.3%20DesignPattern/2.4.3.1%20ListOfDesignPattern.md).

### Отличия между реактивным ([декларативный](../../2.2.1%20TypesOfLanguages.md) "Что делать?") и классическим подходом ([императивным](../../2.2.1%20TypesOfLanguages.md) "Как делать?"):

1) **push вместо pull**

Разница в том, как именно мы работаем с данными. Вместо самостоятельного извлечения каких-либо данных (например, из массива или UserDefaults), мы пишем код таким образом, чтобы **объект сам отправлял актуальные на текущий момент данные, а также все последующие изменения**.

Другими словами, массив (или сервис) перестает быть статичным набором элементов и превращается в поток данных, который сам отправляет содержащиеся в нем элементы один за другим.

2) **auto update**

В [императивном](../../2.2.1%20TypesOfLanguages.md) подходе нам надо самостоятельно следить за данными: проверять на актуальность и обновлять.

В реактивном подходе данные всегда будут в консистентном виде.

Например, в социальной сети для авторизованного пользователя могут быть доступны функции, недоступные анонимному пользователю. А также в зависимости от состояния может по-разному выглядеть интерфейс.

Смена статуса авторизации может произойти на одном табе, а перерисовать экраны мы должны во всем приложении. Пользователь может разлогиниться самостоятельно, а также его может выкинуть система, если, допустим, «протухнет» токен. Что делать?

В императивном подходе без использования паттерна наблюдателя у нас был бы сервис с таймером, время от времени проверяющий статус пользователя. Как только статус изменится, мы бы сохранили его и принудительно перерисовали интерфейс, начав заново опрашивать сервис о статусе. В этом случае мы похожи на ослика из Шрека: «А сейчас? Уже можно? Может, пора?».

В реактивном подходе мы бы просто подписались на изменения в сервисе на нужных экранах и перерисовывали интерфейс при необходимости.

Примером из мира iOS-разработки может послужить переход от MRC к ARC — когда было необходимо самостоятельно следить за количеством сильных ссылок на объект и вызывать методы retain / release.

### Подведем итоги разбора реактивного подхода:

| Плюсы | Минусы |
|---|---|
| Скорость разработки | Сложно «въехать» в новый подход и терминологию |
| Читаемость кода | Дешевизна разработки за счет ее скорости, но вместе с тем и повышение стоимости из-за потребности в найме разработчиков со знанием реактивных подходов (чтобы поддерживать новое детище) |
| Актуальность данных | |

В iOS-разработке время от времени появляются новые инструменты для создания приложений в реактивном подходе, но фаворитов только два: RxSwift и Combine.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/23a/ba5/d0d/23aba5d0dce4fe6cb04b8cbff048721b.png)

[2.2.2.1.1 Functional Programming Theme](./2.2.2.1.1%20FunctionalProgramming(FP).md) | [Back To iOSWiki Contents](https://github.com/eldaroid/iOSWiki) | [2.2.2.2 Imperative Theme](../2.2.2.2%20Imperative/)
